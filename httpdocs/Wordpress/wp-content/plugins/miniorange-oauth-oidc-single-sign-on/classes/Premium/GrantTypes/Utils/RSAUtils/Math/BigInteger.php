<?php


namespace MoOauthClient\GrantTypes;

if (defined("\x4d\x41\x54\x48\137\102\x49\107\x49\x4e\x54\105\107\105\x52\x5f\x4d\x4f\116\x54\x47\x4f\115\x45\122\131")) {
    goto Ui_;
}
define("\x4d\101\124\x48\x5f\102\x49\x47\111\116\x54\105\107\x45\x52\137\x4d\117\x4e\x54\107\117\x4d\105\122\131", 0);
Ui_:
if (defined("\x4d\101\x54\x48\x5f\x42\111\107\111\116\x54\x45\x47\x45\122\x5f\x42\101\122\122\x45\124\124")) {
    goto s6R;
}
define("\x4d\x41\x54\x48\137\x42\111\107\111\116\124\105\107\105\122\x5f\102\x41\122\122\105\x54\x54", 1);
s6R:
if (defined("\x4d\x41\x54\x48\x5f\102\111\x47\x49\x4e\124\x45\x47\x45\122\137\x50\117\127\x45\122\x4f\106\x32")) {
    goto vtd;
}
define("\x4d\101\x54\110\137\102\x49\107\x49\x4e\x54\105\107\x45\x52\x5f\120\x4f\127\x45\x52\117\x46\x32", 2);
vtd:
if (defined("\115\101\x54\x48\x5f\x42\111\x47\111\116\124\x45\107\x45\122\137\x43\114\101\x53\123\111\103")) {
    goto tZg;
}
define("\115\x41\x54\x48\x5f\102\111\x47\x49\116\124\x45\107\105\x52\137\103\114\x41\x53\123\x49\x43", 3);
tZg:
if (defined("\115\x41\x54\110\137\x42\111\107\x49\x4e\124\105\x47\105\x52\x5f\x4e\x4f\116\x45")) {
    goto XKg;
}
define("\x4d\101\124\x48\137\102\x49\107\111\x4e\124\x45\107\x45\122\x5f\x4e\117\116\x45", 4);
XKg:
if (defined("\115\x41\x54\110\137\102\x49\x47\111\x4e\x54\105\x47\x45\x52\137\126\x41\114\x55\105")) {
    goto TUI;
}
define("\x4d\101\124\110\x5f\x42\111\x47\111\116\x54\105\107\105\122\x5f\126\x41\x4c\125\105", 0);
TUI:
if (defined("\115\101\x54\110\x5f\x42\x49\107\x49\116\x54\105\107\105\x52\x5f\x53\x49\x47\x4e")) {
    goto Xpr;
}
define("\115\x41\x54\110\137\x42\x49\x47\x49\116\x54\x45\107\x45\122\x5f\123\x49\x47\116", 1);
Xpr:
if (defined("\115\x41\x54\110\x5f\102\x49\107\111\x4e\124\x45\x47\105\122\x5f\126\101\x52\111\101\102\114\x45")) {
    goto Jv6;
}
define("\x4d\101\x54\x48\137\102\x49\107\111\116\124\x45\107\105\122\x5f\126\101\x52\111\x41\102\114\105", 0);
Jv6:
if (defined("\x4d\101\x54\110\x5f\102\x49\x47\x49\116\x54\105\107\x45\x52\137\x44\101\124\101")) {
    goto iw3;
}
define("\x4d\101\124\x48\x5f\x42\111\x47\x49\116\x54\x45\107\105\x52\137\x44\x41\x54\x41", 1);
iw3:
if (defined("\115\x41\x54\x48\x5f\102\x49\107\111\x4e\124\105\x47\105\x52\137\115\x4f\104\x45\x5f\x49\116\x54\105\x52\x4e\x41\x4c")) {
    goto sIh;
}
define("\115\x41\124\x48\137\x42\111\107\x49\x4e\124\105\x47\x45\x52\137\115\x4f\x44\105\137\111\116\124\x45\122\x4e\101\114", 1);
sIh:
if (defined("\115\x41\124\110\137\x42\111\x47\x49\x4e\x54\105\x47\x45\x52\137\x4d\117\104\x45\137\102\103\115\x41\124\110")) {
    goto i2K;
}
define("\x4d\101\124\110\137\102\111\107\x49\116\124\105\x47\105\x52\x5f\115\117\x44\105\137\102\x43\x4d\101\124\x48", 2);
i2K:
if (defined("\115\101\124\110\137\x42\111\107\111\x4e\x54\105\x47\105\122\137\x4d\117\x44\x45\137\x47\115\120")) {
    goto ZF5;
}
define("\115\x41\x54\x48\137\x42\x49\x47\x49\x4e\124\x45\x47\x45\x52\x5f\x4d\x4f\104\105\x5f\x47\115\x50", 3);
ZF5:
if (defined("\x4d\101\124\110\137\x42\x49\x47\x49\x4e\x54\x45\x47\105\x52\x5f\x4b\101\122\x41\124\x53\125\102\x41\x5f\x43\125\x54\117\x46\106")) {
    goto iZd;
}
define("\x4d\x41\124\x48\x5f\x42\x49\x47\111\x4e\124\x45\107\105\122\x5f\x4b\x41\x52\101\x54\123\125\x42\101\x5f\x43\x55\124\117\106\x46", 25);
iZd:
class Math_BigInteger
{
    var $value;
    var $is_negative = false;
    var $precision = -1;
    var $bitmask = false;
    var $hex;
    function __construct($Av = 0, $Oo = 10)
    {
        if (defined("\x4d\x41\124\110\137\102\x49\107\111\116\x54\105\x47\105\x52\x5f\x4d\117\104\x45")) {
            goto w4G;
        }
        switch (true) {
            case extension_loaded("\147\155\160"):
                define("\115\101\124\x48\137\x42\111\107\x49\116\124\105\x47\105\122\137\x4d\x4f\104\105", MATH_BIGINTEGER_MODE_GMP);
                goto Ob4;
            case extension_loaded("\x62\143\x6d\141\x74\150"):
                define("\115\101\x54\x48\137\x42\x49\x47\x49\x4e\124\x45\107\105\122\x5f\115\x4f\104\105", MATH_BIGINTEGER_MODE_BCMATH);
                goto Ob4;
            default:
                define("\115\101\124\110\137\102\x49\107\111\x4e\124\105\107\105\122\x5f\115\x4f\104\105", MATH_BIGINTEGER_MODE_INTERNAL);
        }
        h25:
        Ob4:
        w4G:
        if (!(extension_loaded("\157\x70\145\x6e\163\163\154") && !defined("\x4d\x41\124\110\137\x42\111\x47\x49\x4e\124\x45\107\105\122\137\x4f\x50\105\116\123\123\x4c\137\x44\111\123\x41\102\114\105") && !defined("\115\x41\x54\x48\137\x42\111\x47\x49\x4e\124\x45\107\105\x52\x5f\x4f\x50\x45\116\x53\x53\114\x5f\x45\x4e\101\102\x4c\x45\104"))) {
            goto GJZ;
        }
        ob_start();
        @phpinfo();
        $Bn = ob_get_contents();
        ob_end_clean();
        preg_match_all("\43\117\160\x65\x6e\123\123\x4c\40\50\x48\145\141\x64\x65\x72\x7c\x4c\x69\x62\x72\x61\x72\x79\x29\40\x56\145\x72\x73\151\x6f\x6e\50\x2e\x2a\51\x23\151\155", $Bn, $EZ);
        $fX = array();
        if (empty($EZ[1])) {
            goto xS1;
        }
        $wz = 0;
        x5v:
        if (!($wz < count($EZ[1]))) {
            goto DhI;
        }
        $Po = trim(str_replace("\75\x3e", '', strip_tags($EZ[2][$wz])));
        if (!preg_match("\x2f\x28\x5c\x64\53\134\56\134\144\x2b\134\x2e\x5c\x64\x2b\51\57\x69", $Po, $x4)) {
            goto ZdK;
        }
        $fX[$EZ[1][$wz]] = $x4[0];
        goto HBx;
        ZdK:
        $fX[$EZ[1][$wz]] = $Po;
        HBx:
        Wrb:
        $wz++;
        goto x5v;
        DhI:
        xS1:
        switch (true) {
            case !isset($fX["\x48\145\x61\x64\145\x72"]):
            case !isset($fX["\x4c\151\142\162\141\162\171"]):
            case $fX["\x48\x65\141\144\145\x72"] == $fX["\114\x69\x62\x72\x61\162\x79"]:
            case version_compare($fX["\x48\x65\x61\144\145\162"], "\x31\x2e\60\56\x30") >= 0 && version_compare($fX["\x4c\x69\142\x72\141\162\x79"], "\61\x2e\60\x2e\60") >= 0:
                define("\x4d\101\x54\110\x5f\x42\111\107\111\116\x54\x45\107\105\x52\137\x4f\x50\x45\116\123\123\x4c\137\105\116\x41\102\114\105\x44", true);
                goto cCx;
            default:
                define("\x4d\101\124\110\x5f\102\111\107\111\x4e\x54\x45\107\x45\x52\x5f\x4f\120\x45\x4e\123\x53\x4c\x5f\x44\x49\123\101\102\114\105", true);
        }
        jd3:
        cCx:
        GJZ:
        if (defined("\x50\x48\x50\x5f\x49\x4e\x54\137\x53\x49\x5a\x45")) {
            goto SQC;
        }
        define("\x50\x48\x50\137\x49\x4e\124\x5f\123\111\132\x45", 4);
        SQC:
        if (!(!defined("\x4d\101\x54\110\x5f\102\111\x47\111\x4e\x54\105\x47\x45\x52\x5f\102\x41\123\105") && MATH_BIGINTEGER_MODE == MATH_BIGINTEGER_MODE_INTERNAL)) {
            goto lGQ;
        }
        switch (PHP_INT_SIZE) {
            case 8:
                define("\x4d\x41\x54\110\x5f\x42\x49\107\x49\x4e\x54\105\x47\105\122\x5f\102\101\x53\x45", 31);
                define("\x4d\101\x54\x48\x5f\102\x49\x47\111\116\x54\x45\107\105\x52\137\102\x41\123\x45\137\x46\125\114\114", 0x80000000);
                define("\x4d\101\124\110\137\x42\111\x47\111\116\124\x45\107\x45\x52\x5f\x4d\x41\130\x5f\104\x49\x47\111\x54", 0x7fffffff);
                define("\x4d\x41\x54\x48\x5f\x42\111\107\x49\116\124\x45\107\105\122\x5f\x4d\x53\x42", 0x40000000);
                define("\x4d\x41\x54\110\137\102\x49\x47\111\116\124\105\107\x45\x52\x5f\x4d\x41\130\x31\60", 1000000000);
                define("\115\101\x54\x48\x5f\x42\111\107\x49\x4e\x54\x45\107\105\x52\137\x4d\x41\x58\61\60\137\114\x45\x4e", 9);
                define("\115\101\x54\110\137\102\111\x47\111\116\x54\105\x47\x45\122\x5f\115\x41\130\x5f\x44\111\107\111\124\62", pow(2, 62));
                goto hOI;
            default:
                define("\x4d\101\x54\110\137\102\x49\x47\111\116\124\x45\x47\105\x52\137\102\101\123\x45", 26);
                define("\x4d\x41\124\x48\137\102\x49\107\x49\x4e\124\x45\x47\105\x52\137\x42\x41\123\105\x5f\x46\x55\x4c\114", 0x4000000);
                define("\115\101\124\110\137\x42\x49\107\111\116\124\105\x47\105\122\x5f\x4d\x41\130\137\x44\x49\107\x49\124", 0x3ffffff);
                define("\115\x41\124\110\137\102\111\107\x49\x4e\124\105\x47\105\x52\137\x4d\123\102", 0x2000000);
                define("\115\x41\x54\x48\137\x42\x49\x47\x49\x4e\x54\x45\107\105\x52\137\115\x41\130\x31\x30", 10000000);
                define("\x4d\101\124\110\137\x42\111\107\111\116\124\105\107\105\122\137\x4d\101\x58\x31\60\137\x4c\105\x4e", 7);
                define("\115\101\124\x48\x5f\x42\x49\x47\x49\116\124\x45\107\105\122\x5f\x4d\101\130\137\104\x49\107\x49\x54\62", pow(2, 52));
        }
        bPI:
        hOI:
        lGQ:
        switch (MATH_BIGINTEGER_MODE) {
            case MATH_BIGINTEGER_MODE_GMP:
                switch (true) {
                    case is_resource($Av) && get_resource_type($Av) == "\107\x4d\120\40\x69\x6e\164\145\147\145\162":
                    case is_object($Av) && get_class($Av) == "\107\x4d\x50":
                        $this->value = $Av;
                        return;
                }
                ih1:
                PlV:
                $this->value = gmp_init(0);
                goto Rv9;
            case MATH_BIGINTEGER_MODE_BCMATH:
                $this->value = "\x30";
                goto Rv9;
            default:
                $this->value = array();
        }
        Du5:
        Rv9:
        if (!(empty($Av) && (abs($Oo) != 256 || $Av !== "\60"))) {
            goto qJO;
        }
        return;
        qJO:
        switch ($Oo) {
            case -256:
                if (!(ord($Av[0]) & 0x80)) {
                    goto qQQ;
                }
                $Av = ~$Av;
                $this->is_negative = true;
                qQQ:
            case 256:
                switch (MATH_BIGINTEGER_MODE) {
                    case MATH_BIGINTEGER_MODE_GMP:
                        $this->value = function_exists("\x67\155\160\137\151\x6d\160\157\162\164") ? gmp_import($Av) : gmp_init("\60\x78" . bin2hex($Av));
                        if (!$this->is_negative) {
                            goto R3m;
                        }
                        $this->value = gmp_neg($this->value);
                        R3m:
                        goto gwa;
                    case MATH_BIGINTEGER_MODE_BCMATH:
                        $Ks = strlen($Av) + 3 & 0xfffffffc;
                        $Av = str_pad($Av, $Ks, chr(0), STR_PAD_LEFT);
                        $wz = 0;
                        r8m:
                        if (!($wz < $Ks)) {
                            goto f2z;
                        }
                        $this->value = bcmul($this->value, "\x34\62\x39\x34\x39\x36\x37\62\71\66", 0);
                        $this->value = bcadd($this->value, 0x1000000 * ord($Av[$wz]) + (ord($Av[$wz + 1]) << 16 | ord($Av[$wz + 2]) << 8 | ord($Av[$wz + 3])), 0);
                        mzH:
                        $wz += 4;
                        goto r8m;
                        f2z:
                        if (!$this->is_negative) {
                            goto Rdg;
                        }
                        $this->value = "\x2d" . $this->value;
                        Rdg:
                        goto gwa;
                    default:
                        Tas:
                        if (!strlen($Av)) {
                            goto cqT;
                        }
                        $this->value[] = $this->_bytes2int($this->_base256_rshift($Av, MATH_BIGINTEGER_BASE));
                        goto Tas;
                        cqT:
                }
                mGM:
                gwa:
                if (!$this->is_negative) {
                    goto Hnn;
                }
                if (!(MATH_BIGINTEGER_MODE != MATH_BIGINTEGER_MODE_INTERNAL)) {
                    goto AXO;
                }
                $this->is_negative = false;
                AXO:
                $gu = $this->add(new Math_BigInteger("\55\61"));
                $this->value = $gu->value;
                Hnn:
                goto UE0;
            case 16:
            case -16:
                if (!($Oo > 0 && $Av[0] == "\x2d")) {
                    goto rBC;
                }
                $this->is_negative = true;
                $Av = substr($Av, 1);
                rBC:
                $Av = preg_replace("\43\136\x28\77\72\x30\x78\x29\77\50\133\x41\x2d\x46\x61\x2d\146\60\x2d\71\135\52\51\56\x2a\x23", "\44\61", $Av);
                $ES = false;
                if (!($Oo < 0 && hexdec($Av[0]) >= 8)) {
                    goto IOo;
                }
                $this->is_negative = $ES = true;
                $Av = bin2hex(~pack("\110\x2a", $Av));
                IOo:
                switch (MATH_BIGINTEGER_MODE) {
                    case MATH_BIGINTEGER_MODE_GMP:
                        $gu = $this->is_negative ? "\x2d\x30\170" . $Av : "\x30\170" . $Av;
                        $this->value = gmp_init($gu);
                        $this->is_negative = false;
                        goto Mue;
                    case MATH_BIGINTEGER_MODE_BCMATH:
                        $Av = strlen($Av) & 1 ? "\x30" . $Av : $Av;
                        $gu = new Math_BigInteger(pack("\x48\52", $Av), 256);
                        $this->value = $this->is_negative ? "\55" . $gu->value : $gu->value;
                        $this->is_negative = false;
                        goto Mue;
                    default:
                        $Av = strlen($Av) & 1 ? "\60" . $Av : $Av;
                        $gu = new Math_BigInteger(pack("\110\x2a", $Av), 256);
                        $this->value = $gu->value;
                }
                R38:
                Mue:
                if (!$ES) {
                    goto PWQ;
                }
                $gu = $this->add(new Math_BigInteger("\x2d\61"));
                $this->value = $gu->value;
                PWQ:
                goto UE0;
            case 10:
            case -10:
                $Av = preg_replace("\x23\50\77\74\41\x5e\51\x28\77\72\55\x29\56\52\x7c\50\x3f\x3c\75\136\x7c\55\x29\60\x2a\x7c\x5b\136\x2d\60\x2d\x39\x5d\56\x2a\43", '', $Av);
                switch (MATH_BIGINTEGER_MODE) {
                    case MATH_BIGINTEGER_MODE_GMP:
                        $this->value = gmp_init($Av);
                        goto UaR;
                    case MATH_BIGINTEGER_MODE_BCMATH:
                        $this->value = $Av === "\x2d" ? "\60" : (string) $Av;
                        goto UaR;
                    default:
                        $gu = new Math_BigInteger();
                        $Eu = new Math_BigInteger();
                        $Eu->value = array(MATH_BIGINTEGER_MAX10);
                        if (!($Av[0] == "\x2d")) {
                            goto z41;
                        }
                        $this->is_negative = true;
                        $Av = substr($Av, 1);
                        z41:
                        $Av = str_pad($Av, strlen($Av) + (MATH_BIGINTEGER_MAX10_LEN - 1) * strlen($Av) % MATH_BIGINTEGER_MAX10_LEN, 0, STR_PAD_LEFT);
                        cYG:
                        if (!strlen($Av)) {
                            goto lPU;
                        }
                        $gu = $gu->multiply($Eu);
                        $gu = $gu->add(new Math_BigInteger($this->_int2bytes(substr($Av, 0, MATH_BIGINTEGER_MAX10_LEN)), 256));
                        $Av = substr($Av, MATH_BIGINTEGER_MAX10_LEN);
                        goto cYG;
                        lPU:
                        $this->value = $gu->value;
                }
                GqM:
                UaR:
                goto UE0;
            case 2:
            case -2:
                if (!($Oo > 0 && $Av[0] == "\x2d")) {
                    goto qks;
                }
                $this->is_negative = true;
                $Av = substr($Av, 1);
                qks:
                $Av = preg_replace("\x23\x5e\x28\133\x30\x31\x5d\x2a\51\x2e\52\x23", "\x24\61", $Av);
                $Av = str_pad($Av, strlen($Av) + 3 * strlen($Av) % 4, 0, STR_PAD_LEFT);
                $MQ = "\60\170";
                aIQ:
                if (!strlen($Av)) {
                    goto w1R;
                }
                $UC = substr($Av, 0, 4);
                $MQ .= dechex(bindec($UC));
                $Av = substr($Av, 4);
                goto aIQ;
                w1R:
                if (!$this->is_negative) {
                    goto xMw;
                }
                $MQ = "\55" . $MQ;
                xMw:
                $gu = new Math_BigInteger($MQ, 8 * $Oo);
                $this->value = $gu->value;
                $this->is_negative = $gu->is_negative;
                goto UE0;
            default:
        }
        GoW:
        UE0:
    }
    function Math_BigInteger($Av = 0, $Oo = 10)
    {
        $this->__construct($Av, $Oo);
    }
    function toBytes($gL = false)
    {
        if (!$gL) {
            goto bVi;
        }
        $Zv = $this->compare(new Math_BigInteger());
        if (!($Zv == 0)) {
            goto j9M;
        }
        return $this->precision > 0 ? str_repeat(chr(0), $this->precision + 1 >> 3) : '';
        j9M:
        $gu = $Zv < 0 ? $this->add(new Math_BigInteger(1)) : $this->copy();
        $DJ = $gu->toBytes();
        if (!empty($DJ)) {
            goto cyN;
        }
        $DJ = chr(0);
        cyN:
        if (!(ord($DJ[0]) & 0x80)) {
            goto MzS;
        }
        $DJ = chr(0) . $DJ;
        MzS:
        return $Zv < 0 ? ~$DJ : $DJ;
        bVi:
        switch (MATH_BIGINTEGER_MODE) {
            case MATH_BIGINTEGER_MODE_GMP:
                if (!(gmp_cmp($this->value, gmp_init(0)) == 0)) {
                    goto SKM;
                }
                return $this->precision > 0 ? str_repeat(chr(0), $this->precision + 1 >> 3) : '';
                SKM:
                if (function_exists("\x67\x6d\x70\137\x65\170\160\157\x72\164")) {
                    goto zD1;
                }
                $gu = gmp_strval(gmp_abs($this->value), 16);
                $gu = strlen($gu) & 1 ? "\x30" . $gu : $gu;
                $gu = pack("\x48\52", $gu);
                goto gn0;
                zD1:
                $gu = gmp_export($this->value);
                gn0:
                return $this->precision > 0 ? substr(str_pad($gu, $this->precision >> 3, chr(0), STR_PAD_LEFT), -($this->precision >> 3)) : ltrim($gu, chr(0));
            case MATH_BIGINTEGER_MODE_BCMATH:
                if (!($this->value === "\60")) {
                    goto C4w;
                }
                return $this->precision > 0 ? str_repeat(chr(0), $this->precision + 1 >> 3) : '';
                C4w:
                $mB = '';
                $aZ = $this->value;
                if (!($aZ[0] == "\x2d")) {
                    goto hQ4;
                }
                $aZ = substr($aZ, 1);
                hQ4:
                HFE:
                if (!(bccomp($aZ, "\60", 0) > 0)) {
                    goto EZw;
                }
                $gu = bcmod($aZ, "\61\66\67\x37\x37\x32\61\x36");
                $mB = chr($gu >> 16) . chr($gu >> 8) . chr($gu) . $mB;
                $aZ = bcdiv($aZ, "\x31\x36\x37\x37\x37\x32\x31\66", 0);
                goto HFE;
                EZw:
                return $this->precision > 0 ? substr(str_pad($mB, $this->precision >> 3, chr(0), STR_PAD_LEFT), -($this->precision >> 3)) : ltrim($mB, chr(0));
        }
        F2t:
        L80:
        if (count($this->value)) {
            goto HCl;
        }
        return $this->precision > 0 ? str_repeat(chr(0), $this->precision + 1 >> 3) : '';
        HCl:
        $NU = $this->_int2bytes($this->value[count($this->value) - 1]);
        $gu = $this->copy();
        $wz = count($gu->value) - 2;
        tzM:
        if (!($wz >= 0)) {
            goto ELM;
        }
        $gu->_base256_lshift($NU, MATH_BIGINTEGER_BASE);
        $NU = $NU | str_pad($gu->_int2bytes($gu->value[$wz]), strlen($NU), chr(0), STR_PAD_LEFT);
        EYq:
        --$wz;
        goto tzM;
        ELM:
        return $this->precision > 0 ? str_pad(substr($NU, -($this->precision + 7 >> 3)), $this->precision + 7 >> 3, chr(0), STR_PAD_LEFT) : $NU;
    }
    function toHex($gL = false)
    {
        return bin2hex($this->toBytes($gL));
    }
    function toBits($gL = false)
    {
        $iy = $this->toHex($gL);
        $fZ = '';
        $wz = strlen($iy) - 8;
        $uY = strlen($iy) & 7;
        WmT:
        if (!($wz >= $uY)) {
            goto zfu;
        }
        $fZ = str_pad(decbin(hexdec(substr($iy, $wz, 8))), 32, "\x30", STR_PAD_LEFT) . $fZ;
        OlP:
        $wz -= 8;
        goto WmT;
        zfu:
        if (!$uY) {
            goto Bik;
        }
        $fZ = str_pad(decbin(hexdec(substr($iy, 0, $uY))), 8, "\60", STR_PAD_LEFT) . $fZ;
        Bik:
        $NU = $this->precision > 0 ? substr($fZ, -$this->precision) : ltrim($fZ, "\x30");
        if (!($gL && $this->compare(new Math_BigInteger()) > 0 && $this->precision <= 0)) {
            goto u92;
        }
        return "\x30" . $NU;
        u92:
        return $NU;
    }
    function toString()
    {
        switch (MATH_BIGINTEGER_MODE) {
            case MATH_BIGINTEGER_MODE_GMP:
                return gmp_strval($this->value);
            case MATH_BIGINTEGER_MODE_BCMATH:
                if (!($this->value === "\60")) {
                    goto rmL;
                }
                return "\60";
                rmL:
                return ltrim($this->value, "\60");
        }
        Y7T:
        CYI:
        if (count($this->value)) {
            goto orl;
        }
        return "\x30";
        orl:
        $gu = $this->copy();
        $gu->is_negative = false;
        $GM = new Math_BigInteger();
        $GM->value = array(MATH_BIGINTEGER_MAX10);
        $NU = '';
        BAO:
        if (!count($gu->value)) {
            goto Uc0;
        }
        list($gu, $Di) = $gu->divide($GM);
        $NU = str_pad(isset($Di->value[0]) ? $Di->value[0] : '', MATH_BIGINTEGER_MAX10_LEN, "\x30", STR_PAD_LEFT) . $NU;
        goto BAO;
        Uc0:
        $NU = ltrim($NU, "\60");
        if (!empty($NU)) {
            goto N8_;
        }
        $NU = "\60";
        N8_:
        if (!$this->is_negative) {
            goto OiZ;
        }
        $NU = "\x2d" . $NU;
        OiZ:
        return $NU;
    }
    function copy()
    {
        $gu = new Math_BigInteger();
        $gu->value = $this->value;
        $gu->is_negative = $this->is_negative;
        $gu->precision = $this->precision;
        $gu->bitmask = $this->bitmask;
        return $gu;
    }
    function __toString()
    {
        return $this->toString();
    }
    function __clone()
    {
        return $this->copy();
    }
    function __sleep()
    {
        $this->hex = $this->toHex(true);
        $TX = array("\x68\x65\170");
        if (!($this->precision > 0)) {
            goto iz8;
        }
        $TX[] = "\160\x72\x65\143\x69\163\x69\x6f\156";
        iz8:
        return $TX;
    }
    function __wakeup()
    {
        $gu = new Math_BigInteger($this->hex, -16);
        $this->value = $gu->value;
        $this->is_negative = $gu->is_negative;
        if (!($this->precision > 0)) {
            goto OOT;
        }
        $this->setPrecision($this->precision);
        OOT:
    }
    function __debugInfo()
    {
        $w7 = array();
        switch (MATH_BIGINTEGER_MODE) {
            case MATH_BIGINTEGER_MODE_GMP:
                $tY = "\x67\155\160";
                goto l7b;
            case MATH_BIGINTEGER_MODE_BCMATH:
                $tY = "\142\x63\155\141\164\x68";
                goto l7b;
            case MATH_BIGINTEGER_MODE_INTERNAL:
                $tY = "\x69\156\164\x65\x72\156\141\x6c";
                $w7[] = PHP_INT_SIZE == 8 ? "\x36\x34\x2d\x62\x69\x74" : "\63\x32\x2d\x62\x69\164";
        }
        jEg:
        l7b:
        if (!(MATH_BIGINTEGER_MODE != MATH_BIGINTEGER_MODE_GMP && defined("\x4d\101\x54\110\137\102\111\107\x49\x4e\x54\x45\x47\105\122\137\117\120\105\x4e\x53\123\114\137\x45\x4e\101\102\114\105\x44"))) {
            goto mW3;
        }
        $w7[] = "\117\x70\145\156\123\x53\114";
        mW3:
        if (empty($w7)) {
            goto LIf;
        }
        $tY .= "\40\50" . implode($w7, "\x2c\x20") . "\x29";
        LIf:
        return array("\166\x61\154\x75\145" => "\x30\170" . $this->toHex(true), "\145\156\147\x69\156\145" => $tY);
    }
    function add($Pe)
    {
        switch (MATH_BIGINTEGER_MODE) {
            case MATH_BIGINTEGER_MODE_GMP:
                $gu = new Math_BigInteger();
                $gu->value = gmp_add($this->value, $Pe->value);
                return $this->_normalize($gu);
            case MATH_BIGINTEGER_MODE_BCMATH:
                $gu = new Math_BigInteger();
                $gu->value = bcadd($this->value, $Pe->value, 0);
                return $this->_normalize($gu);
        }
        wGm:
        dld:
        $gu = $this->_add($this->value, $this->is_negative, $Pe->value, $Pe->is_negative);
        $NU = new Math_BigInteger();
        $NU->value = $gu[MATH_BIGINTEGER_VALUE];
        $NU->is_negative = $gu[MATH_BIGINTEGER_SIGN];
        return $this->_normalize($NU);
    }
    function _add($HC, $Kk, $zy, $Xo)
    {
        $Vt = count($HC);
        $FD = count($zy);
        if ($Vt == 0) {
            goto WBm;
        }
        if ($FD == 0) {
            goto xnr;
        }
        goto OGa;
        WBm:
        return array(MATH_BIGINTEGER_VALUE => $zy, MATH_BIGINTEGER_SIGN => $Xo);
        goto OGa;
        xnr:
        return array(MATH_BIGINTEGER_VALUE => $HC, MATH_BIGINTEGER_SIGN => $Kk);
        OGa:
        if (!($Kk != $Xo)) {
            goto GhS;
        }
        if (!($HC == $zy)) {
            goto QTs;
        }
        return array(MATH_BIGINTEGER_VALUE => array(), MATH_BIGINTEGER_SIGN => false);
        QTs:
        $gu = $this->_subtract($HC, false, $zy, false);
        $gu[MATH_BIGINTEGER_SIGN] = $this->_compare($HC, false, $zy, false) > 0 ? $Kk : $Xo;
        return $gu;
        GhS:
        if ($Vt < $FD) {
            goto JGN;
        }
        $wC = $FD;
        $mB = $HC;
        goto hVG;
        JGN:
        $wC = $Vt;
        $mB = $zy;
        hVG:
        $mB[count($mB)] = 0;
        $DS = 0;
        $wz = 0;
        $L4 = 1;
        V8S:
        if (!($L4 < $wC)) {
            goto xT6;
        }
        $Ng = $HC[$L4] * MATH_BIGINTEGER_BASE_FULL + $HC[$wz] + $zy[$L4] * MATH_BIGINTEGER_BASE_FULL + $zy[$wz] + $DS;
        $DS = $Ng >= MATH_BIGINTEGER_MAX_DIGIT2;
        $Ng = $DS ? $Ng - MATH_BIGINTEGER_MAX_DIGIT2 : $Ng;
        $gu = MATH_BIGINTEGER_BASE === 26 ? intval($Ng / 0x4000000) : $Ng >> 31;
        $mB[$wz] = (int) ($Ng - MATH_BIGINTEGER_BASE_FULL * $gu);
        $mB[$L4] = $gu;
        V79:
        $wz += 2;
        $L4 += 2;
        goto V8S;
        xT6:
        if (!($L4 == $wC)) {
            goto DiG;
        }
        $Ng = $HC[$wz] + $zy[$wz] + $DS;
        $DS = $Ng >= MATH_BIGINTEGER_BASE_FULL;
        $mB[$wz] = $DS ? $Ng - MATH_BIGINTEGER_BASE_FULL : $Ng;
        ++$wz;
        DiG:
        if (!$DS) {
            goto KyW;
        }
        FAi:
        if (!($mB[$wz] == MATH_BIGINTEGER_MAX_DIGIT)) {
            goto vZN;
        }
        $mB[$wz] = 0;
        bae:
        ++$wz;
        goto FAi;
        vZN:
        ++$mB[$wz];
        KyW:
        return array(MATH_BIGINTEGER_VALUE => $this->_trim($mB), MATH_BIGINTEGER_SIGN => $Kk);
    }
    function subtract($Pe)
    {
        switch (MATH_BIGINTEGER_MODE) {
            case MATH_BIGINTEGER_MODE_GMP:
                $gu = new Math_BigInteger();
                $gu->value = gmp_sub($this->value, $Pe->value);
                return $this->_normalize($gu);
            case MATH_BIGINTEGER_MODE_BCMATH:
                $gu = new Math_BigInteger();
                $gu->value = bcsub($this->value, $Pe->value, 0);
                return $this->_normalize($gu);
        }
        zMj:
        kkn:
        $gu = $this->_subtract($this->value, $this->is_negative, $Pe->value, $Pe->is_negative);
        $NU = new Math_BigInteger();
        $NU->value = $gu[MATH_BIGINTEGER_VALUE];
        $NU->is_negative = $gu[MATH_BIGINTEGER_SIGN];
        return $this->_normalize($NU);
    }
    function _subtract($HC, $Kk, $zy, $Xo)
    {
        $Vt = count($HC);
        $FD = count($zy);
        if ($Vt == 0) {
            goto ujD;
        }
        if ($FD == 0) {
            goto k5r;
        }
        goto YIA;
        ujD:
        return array(MATH_BIGINTEGER_VALUE => $zy, MATH_BIGINTEGER_SIGN => !$Xo);
        goto YIA;
        k5r:
        return array(MATH_BIGINTEGER_VALUE => $HC, MATH_BIGINTEGER_SIGN => $Kk);
        YIA:
        if (!($Kk != $Xo)) {
            goto RGV;
        }
        $gu = $this->_add($HC, false, $zy, false);
        $gu[MATH_BIGINTEGER_SIGN] = $Kk;
        return $gu;
        RGV:
        $b1 = $this->_compare($HC, $Kk, $zy, $Xo);
        if ($b1) {
            goto RMn;
        }
        return array(MATH_BIGINTEGER_VALUE => array(), MATH_BIGINTEGER_SIGN => false);
        RMn:
        if (!(!$Kk && $b1 < 0 || $Kk && $b1 > 0)) {
            goto F9U;
        }
        $gu = $HC;
        $HC = $zy;
        $zy = $gu;
        $Kk = !$Kk;
        $Vt = count($HC);
        $FD = count($zy);
        F9U:
        $DS = 0;
        $wz = 0;
        $L4 = 1;
        A1a:
        if (!($L4 < $FD)) {
            goto HTc;
        }
        $Ng = $HC[$L4] * MATH_BIGINTEGER_BASE_FULL + $HC[$wz] - $zy[$L4] * MATH_BIGINTEGER_BASE_FULL - $zy[$wz] - $DS;
        $DS = $Ng < 0;
        $Ng = $DS ? $Ng + MATH_BIGINTEGER_MAX_DIGIT2 : $Ng;
        $gu = MATH_BIGINTEGER_BASE === 26 ? intval($Ng / 0x4000000) : $Ng >> 31;
        $HC[$wz] = (int) ($Ng - MATH_BIGINTEGER_BASE_FULL * $gu);
        $HC[$L4] = $gu;
        s1S:
        $wz += 2;
        $L4 += 2;
        goto A1a;
        HTc:
        if (!($L4 == $FD)) {
            goto GTJ;
        }
        $Ng = $HC[$wz] - $zy[$wz] - $DS;
        $DS = $Ng < 0;
        $HC[$wz] = $DS ? $Ng + MATH_BIGINTEGER_BASE_FULL : $Ng;
        ++$wz;
        GTJ:
        if (!$DS) {
            goto f1W;
        }
        eCq:
        if ($HC[$wz]) {
            goto vX_;
        }
        $HC[$wz] = MATH_BIGINTEGER_MAX_DIGIT;
        QA5:
        ++$wz;
        goto eCq;
        vX_:
        --$HC[$wz];
        f1W:
        return array(MATH_BIGINTEGER_VALUE => $this->_trim($HC), MATH_BIGINTEGER_SIGN => $Kk);
    }
    function multiply($Av)
    {
        switch (MATH_BIGINTEGER_MODE) {
            case MATH_BIGINTEGER_MODE_GMP:
                $gu = new Math_BigInteger();
                $gu->value = gmp_mul($this->value, $Av->value);
                return $this->_normalize($gu);
            case MATH_BIGINTEGER_MODE_BCMATH:
                $gu = new Math_BigInteger();
                $gu->value = bcmul($this->value, $Av->value, 0);
                return $this->_normalize($gu);
        }
        w0F:
        z1O:
        $gu = $this->_multiply($this->value, $this->is_negative, $Av->value, $Av->is_negative);
        $jm = new Math_BigInteger();
        $jm->value = $gu[MATH_BIGINTEGER_VALUE];
        $jm->is_negative = $gu[MATH_BIGINTEGER_SIGN];
        return $this->_normalize($jm);
    }
    function _multiply($HC, $Kk, $zy, $Xo)
    {
        $ye = count($HC);
        $oS = count($zy);
        if (!(!$ye || !$oS)) {
            goto KQP;
        }
        return array(MATH_BIGINTEGER_VALUE => array(), MATH_BIGINTEGER_SIGN => false);
        KQP:
        return array(MATH_BIGINTEGER_VALUE => min($ye, $oS) < 2 * MATH_BIGINTEGER_KARATSUBA_CUTOFF ? $this->_trim($this->_regularMultiply($HC, $zy)) : $this->_trim($this->_karatsuba($HC, $zy)), MATH_BIGINTEGER_SIGN => $Kk != $Xo);
    }
    function _regularMultiply($HC, $zy)
    {
        $ye = count($HC);
        $oS = count($zy);
        if (!(!$ye || !$oS)) {
            goto DZW;
        }
        return array();
        DZW:
        if (!($ye < $oS)) {
            goto eTp;
        }
        $gu = $HC;
        $HC = $zy;
        $zy = $gu;
        $ye = count($HC);
        $oS = count($zy);
        eTp:
        $Xy = $this->_array_repeat(0, $ye + $oS);
        $DS = 0;
        $L4 = 0;
        Pld:
        if (!($L4 < $ye)) {
            goto dRG;
        }
        $gu = $HC[$L4] * $zy[0] + $DS;
        $DS = MATH_BIGINTEGER_BASE === 26 ? intval($gu / 0x4000000) : $gu >> 31;
        $Xy[$L4] = (int) ($gu - MATH_BIGINTEGER_BASE_FULL * $DS);
        NUr:
        ++$L4;
        goto Pld;
        dRG:
        $Xy[$L4] = $DS;
        $wz = 1;
        E10:
        if (!($wz < $oS)) {
            goto hmc;
        }
        $DS = 0;
        $L4 = 0;
        $lm = $wz;
        Atu:
        if (!($L4 < $ye)) {
            goto Y4M;
        }
        $gu = $Xy[$lm] + $HC[$L4] * $zy[$wz] + $DS;
        $DS = MATH_BIGINTEGER_BASE === 26 ? intval($gu / 0x4000000) : $gu >> 31;
        $Xy[$lm] = (int) ($gu - MATH_BIGINTEGER_BASE_FULL * $DS);
        tZW:
        ++$L4;
        ++$lm;
        goto Atu;
        Y4M:
        $Xy[$lm] = $DS;
        JyT:
        ++$wz;
        goto E10;
        hmc:
        return $Xy;
    }
    function _karatsuba($HC, $zy)
    {
        $x4 = min(count($HC) >> 1, count($zy) >> 1);
        if (!($x4 < MATH_BIGINTEGER_KARATSUBA_CUTOFF)) {
            goto D4O;
        }
        return $this->_regularMultiply($HC, $zy);
        D4O:
        $WH = array_slice($HC, $x4);
        $Hg = array_slice($HC, 0, $x4);
        $gH = array_slice($zy, $x4);
        $UY = array_slice($zy, 0, $x4);
        $rb = $this->_karatsuba($WH, $gH);
        $B2 = $this->_karatsuba($Hg, $UY);
        $xj = $this->_add($WH, false, $Hg, false);
        $gu = $this->_add($gH, false, $UY, false);
        $xj = $this->_karatsuba($xj[MATH_BIGINTEGER_VALUE], $gu[MATH_BIGINTEGER_VALUE]);
        $gu = $this->_add($rb, false, $B2, false);
        $xj = $this->_subtract($xj, false, $gu[MATH_BIGINTEGER_VALUE], false);
        $rb = array_merge(array_fill(0, 2 * $x4, 0), $rb);
        $xj[MATH_BIGINTEGER_VALUE] = array_merge(array_fill(0, $x4, 0), $xj[MATH_BIGINTEGER_VALUE]);
        $Sd = $this->_add($rb, false, $xj[MATH_BIGINTEGER_VALUE], $xj[MATH_BIGINTEGER_SIGN]);
        $Sd = $this->_add($Sd[MATH_BIGINTEGER_VALUE], $Sd[MATH_BIGINTEGER_SIGN], $B2, false);
        return $Sd[MATH_BIGINTEGER_VALUE];
    }
    function _square($Av = false)
    {
        return count($Av) < 2 * MATH_BIGINTEGER_KARATSUBA_CUTOFF ? $this->_trim($this->_baseSquare($Av)) : $this->_trim($this->_karatsubaSquare($Av));
    }
    function _baseSquare($mB)
    {
        if (!empty($mB)) {
            goto vej;
        }
        return array();
        vej:
        $b9 = $this->_array_repeat(0, 2 * count($mB));
        $wz = 0;
        $Xs = count($mB) - 1;
        y53:
        if (!($wz <= $Xs)) {
            goto luK;
        }
        $dy = $wz << 1;
        $gu = $b9[$dy] + $mB[$wz] * $mB[$wz];
        $DS = MATH_BIGINTEGER_BASE === 26 ? intval($gu / 0x4000000) : $gu >> 31;
        $b9[$dy] = (int) ($gu - MATH_BIGINTEGER_BASE_FULL * $DS);
        $L4 = $wz + 1;
        $lm = $dy + 1;
        gQz:
        if (!($L4 <= $Xs)) {
            goto g3P;
        }
        $gu = $b9[$lm] + 2 * $mB[$L4] * $mB[$wz] + $DS;
        $DS = MATH_BIGINTEGER_BASE === 26 ? intval($gu / 0x4000000) : $gu >> 31;
        $b9[$lm] = (int) ($gu - MATH_BIGINTEGER_BASE_FULL * $DS);
        yhm:
        ++$L4;
        ++$lm;
        goto gQz;
        g3P:
        $b9[$wz + $Xs + 1] = $DS;
        W0e:
        ++$wz;
        goto y53;
        luK:
        return $b9;
    }
    function _karatsubaSquare($mB)
    {
        $x4 = count($mB) >> 1;
        if (!($x4 < MATH_BIGINTEGER_KARATSUBA_CUTOFF)) {
            goto pEF;
        }
        return $this->_baseSquare($mB);
        pEF:
        $WH = array_slice($mB, $x4);
        $Hg = array_slice($mB, 0, $x4);
        $rb = $this->_karatsubaSquare($WH);
        $B2 = $this->_karatsubaSquare($Hg);
        $xj = $this->_add($WH, false, $Hg, false);
        $xj = $this->_karatsubaSquare($xj[MATH_BIGINTEGER_VALUE]);
        $gu = $this->_add($rb, false, $B2, false);
        $xj = $this->_subtract($xj, false, $gu[MATH_BIGINTEGER_VALUE], false);
        $rb = array_merge(array_fill(0, 2 * $x4, 0), $rb);
        $xj[MATH_BIGINTEGER_VALUE] = array_merge(array_fill(0, $x4, 0), $xj[MATH_BIGINTEGER_VALUE]);
        $NQ = $this->_add($rb, false, $xj[MATH_BIGINTEGER_VALUE], $xj[MATH_BIGINTEGER_SIGN]);
        $NQ = $this->_add($NQ[MATH_BIGINTEGER_VALUE], $NQ[MATH_BIGINTEGER_SIGN], $B2, false);
        return $NQ[MATH_BIGINTEGER_VALUE];
    }
    function divide($Pe)
    {
        switch (MATH_BIGINTEGER_MODE) {
            case MATH_BIGINTEGER_MODE_GMP:
                $N_ = new Math_BigInteger();
                $st = new Math_BigInteger();
                list($N_->value, $st->value) = gmp_div_qr($this->value, $Pe->value);
                if (!(gmp_sign($st->value) < 0)) {
                    goto e0B;
                }
                $st->value = gmp_add($st->value, gmp_abs($Pe->value));
                e0B:
                return array($this->_normalize($N_), $this->_normalize($st));
            case MATH_BIGINTEGER_MODE_BCMATH:
                $N_ = new Math_BigInteger();
                $st = new Math_BigInteger();
                $N_->value = bcdiv($this->value, $Pe->value, 0);
                $st->value = bcmod($this->value, $Pe->value);
                if (!($st->value[0] == "\55")) {
                    goto GjQ;
                }
                $st->value = bcadd($st->value, $Pe->value[0] == "\55" ? substr($Pe->value, 1) : $Pe->value, 0);
                GjQ:
                return array($this->_normalize($N_), $this->_normalize($st));
        }
        P6f:
        pJh:
        if (!(count($Pe->value) == 1)) {
            goto KHp;
        }
        list($oi, $AL) = $this->_divide_digit($this->value, $Pe->value[0]);
        $N_ = new Math_BigInteger();
        $st = new Math_BigInteger();
        $N_->value = $oi;
        $st->value = array($AL);
        $N_->is_negative = $this->is_negative != $Pe->is_negative;
        return array($this->_normalize($N_), $this->_normalize($st));
        KHp:
        static $AK;
        if (isset($AK)) {
            goto n_I;
        }
        $AK = new Math_BigInteger();
        n_I:
        $Av = $this->copy();
        $Pe = $Pe->copy();
        $uU = $Av->is_negative;
        $oE = $Pe->is_negative;
        $Av->is_negative = $Pe->is_negative = false;
        $b1 = $Av->compare($Pe);
        if ($b1) {
            goto te1;
        }
        $gu = new Math_BigInteger();
        $gu->value = array(1);
        $gu->is_negative = $uU != $oE;
        return array($this->_normalize($gu), $this->_normalize(new Math_BigInteger()));
        te1:
        if (!($b1 < 0)) {
            goto aAO;
        }
        if (!$uU) {
            goto C1C;
        }
        $Av = $Pe->subtract($Av);
        C1C:
        return array($this->_normalize(new Math_BigInteger()), $this->_normalize($Av));
        aAO:
        $Zj = $Pe->value[count($Pe->value) - 1];
        $FA = 0;
        iVJ:
        if ($Zj & MATH_BIGINTEGER_MSB) {
            goto ujf;
        }
        $Zj <<= 1;
        rjl:
        ++$FA;
        goto iVJ;
        ujf:
        $Av->_lshift($FA);
        $Pe->_lshift($FA);
        $zy =& $Pe->value;
        $ti = count($Av->value) - 1;
        $MJ = count($Pe->value) - 1;
        $N_ = new Math_BigInteger();
        $Cn =& $N_->value;
        $Cn = $this->_array_repeat(0, $ti - $MJ + 1);
        static $gu, $tl, $Vc;
        if (isset($gu)) {
            goto Mjg;
        }
        $gu = new Math_BigInteger();
        $tl = new Math_BigInteger();
        $Vc = new Math_BigInteger();
        Mjg:
        $vx =& $gu->value;
        $wP =& $Vc->value;
        $vx = array_merge($this->_array_repeat(0, $ti - $MJ), $zy);
        lqo:
        if (!($Av->compare($gu) >= 0)) {
            goto qOa;
        }
        ++$Cn[$ti - $MJ];
        $Av = $Av->subtract($gu);
        $ti = count($Av->value) - 1;
        goto lqo;
        qOa:
        $wz = $ti;
        x6V:
        if (!($wz >= $MJ + 1)) {
            goto XLQ;
        }
        $HC =& $Av->value;
        $eB = array(isset($HC[$wz]) ? $HC[$wz] : 0, isset($HC[$wz - 1]) ? $HC[$wz - 1] : 0, isset($HC[$wz - 2]) ? $HC[$wz - 2] : 0);
        $OU = array($zy[$MJ], $MJ > 0 ? $zy[$MJ - 1] : 0);
        $Pn = $wz - $MJ - 1;
        if ($eB[0] == $OU[0]) {
            goto o6H;
        }
        $Cn[$Pn] = $this->_safe_divide($eB[0] * MATH_BIGINTEGER_BASE_FULL + $eB[1], $OU[0]);
        goto R1F;
        o6H:
        $Cn[$Pn] = MATH_BIGINTEGER_MAX_DIGIT;
        R1F:
        $vx = array($OU[1], $OU[0]);
        $tl->value = array($Cn[$Pn]);
        $tl = $tl->multiply($gu);
        $wP = array($eB[2], $eB[1], $eB[0]);
        TXD:
        if (!($tl->compare($Vc) > 0)) {
            goto XvS;
        }
        --$Cn[$Pn];
        $tl->value = array($Cn[$Pn]);
        $tl = $tl->multiply($gu);
        goto TXD;
        XvS:
        $bV = $this->_array_repeat(0, $Pn);
        $vx = array($Cn[$Pn]);
        $gu = $gu->multiply($Pe);
        $vx =& $gu->value;
        $vx = array_merge($bV, $vx);
        $Av = $Av->subtract($gu);
        if (!($Av->compare($AK) < 0)) {
            goto BZd;
        }
        $vx = array_merge($bV, $zy);
        $Av = $Av->add($gu);
        --$Cn[$Pn];
        BZd:
        $ti = count($HC) - 1;
        g2G:
        --$wz;
        goto x6V;
        XLQ:
        $Av->_rshift($FA);
        $N_->is_negative = $uU != $oE;
        if (!$uU) {
            goto bum;
        }
        $Pe->_rshift($FA);
        $Av = $Pe->subtract($Av);
        bum:
        return array($this->_normalize($N_), $this->_normalize($Av));
    }
    function _divide_digit($kn, $GM)
    {
        $DS = 0;
        $NU = array();
        $wz = count($kn) - 1;
        iBm:
        if (!($wz >= 0)) {
            goto dpi;
        }
        $gu = MATH_BIGINTEGER_BASE_FULL * $DS + $kn[$wz];
        $NU[$wz] = $this->_safe_divide($gu, $GM);
        $DS = (int) ($gu - $GM * $NU[$wz]);
        n_T:
        --$wz;
        goto iBm;
        dpi:
        return array($NU, $DS);
    }
    function modPow($tS, $ze)
    {
        $ze = $this->bitmask !== false && $this->bitmask->compare($ze) < 0 ? $this->bitmask : $ze->abs();
        if (!($tS->compare(new Math_BigInteger()) < 0)) {
            goto B2L;
        }
        $tS = $tS->abs();
        $gu = $this->modInverse($ze);
        if (!($gu === false)) {
            goto qyn;
        }
        return false;
        qyn:
        return $this->_normalize($gu->modPow($tS, $ze));
        B2L:
        if (!(MATH_BIGINTEGER_MODE == MATH_BIGINTEGER_MODE_GMP)) {
            goto Tv3;
        }
        $gu = new Math_BigInteger();
        $gu->value = gmp_powm($this->value, $tS->value, $ze->value);
        return $this->_normalize($gu);
        Tv3:
        if (!($this->compare(new Math_BigInteger()) < 0 || $this->compare($ze) > 0)) {
            goto ph6;
        }
        list(, $gu) = $this->divide($ze);
        return $gu->modPow($tS, $ze);
        ph6:
        if (!defined("\115\101\124\x48\137\102\111\107\111\x4e\124\x45\x47\x45\122\x5f\x4f\120\x45\116\123\123\114\137\105\x4e\x41\102\x4c\105\x44")) {
            goto UJf;
        }
        $kK = array("\155\x6f\144\x75\154\x75\x73" => $ze->toBytes(true), "\x70\165\x62\x6c\151\143\x45\170\x70\157\156\145\x6e\x74" => $tS->toBytes(true));
        $kK = array("\x6d\157\144\x75\x6c\x75\163" => pack("\103\x61\x2a\141\x2a", 2, $this->_encodeASN1Length(strlen($kK["\x6d\157\x64\165\154\x75\x73"])), $kK["\x6d\x6f\x64\165\x6c\x75\163"]), "\160\165\142\154\151\x63\x45\170\160\x6f\x6e\145\156\164" => pack("\103\x61\52\141\x2a", 2, $this->_encodeASN1Length(strlen($kK["\160\x75\x62\x6c\151\143\x45\x78\160\x6f\x6e\x65\156\164"])), $kK["\160\x75\x62\154\x69\x63\x45\x78\x70\x6f\156\x65\156\164"]));
        $EB = pack("\x43\x61\52\141\52\x61\x2a", 48, $this->_encodeASN1Length(strlen($kK["\x6d\157\x64\165\154\165\163"]) + strlen($kK["\x70\165\x62\x6c\151\x63\105\x78\160\157\156\145\x6e\x74"])), $kK["\155\157\x64\x75\x6c\x75\x73"], $kK["\160\165\142\x6c\x69\x63\x45\170\x70\157\x6e\x65\x6e\x74"]);
        $bJ = pack("\x48\x2a", "\63\x30\x30\x64\x30\66\60\x39\62\x61\70\x36\x34\70\x38\66\x66\67\x30\x64\60\x31\x30\61\60\61\x30\x35\60\x30");
        $EB = chr(0) . $EB;
        $EB = chr(3) . $this->_encodeASN1Length(strlen($EB)) . $EB;
        $RS = pack("\103\x61\x2a\x61\52", 48, $this->_encodeASN1Length(strlen($bJ . $EB)), $bJ . $EB);
        $EB = "\x2d\x2d\x2d\x2d\x2d\x42\x45\x47\111\116\x20\x50\x55\102\114\111\103\40\113\105\x59\x2d\x2d\x2d\x2d\x2d\xd\12" . chunk_split(base64_encode($RS)) . "\55\55\55\x2d\x2d\x45\116\104\40\120\125\x42\x4c\x49\103\40\113\105\x59\x2d\55\55\55\x2d";
        $Io = str_pad($this->toBytes(), strlen($ze->toBytes(true)) - 1, "\x0", STR_PAD_LEFT);
        if (!openssl_public_encrypt($Io, $NU, $EB, OPENSSL_NO_PADDING)) {
            goto T9y;
        }
        return new Math_BigInteger($NU, 256);
        T9y:
        UJf:
        if (!(MATH_BIGINTEGER_MODE == MATH_BIGINTEGER_MODE_BCMATH)) {
            goto ad3;
        }
        $gu = new Math_BigInteger();
        $gu->value = bcpowmod($this->value, $tS->value, $ze->value, 0);
        return $this->_normalize($gu);
        ad3:
        if (!empty($tS->value)) {
            goto ovw;
        }
        $gu = new Math_BigInteger();
        $gu->value = array(1);
        return $this->_normalize($gu);
        ovw:
        if (!($tS->value == array(1))) {
            goto e_d;
        }
        list(, $gu) = $this->divide($ze);
        return $this->_normalize($gu);
        e_d:
        if (!($tS->value == array(2))) {
            goto uhv;
        }
        $gu = new Math_BigInteger();
        $gu->value = $this->_square($this->value);
        list(, $gu) = $gu->divide($ze);
        return $this->_normalize($gu);
        uhv:
        return $this->_normalize($this->_slidingWindow($tS, $ze, MATH_BIGINTEGER_BARRETT));
        if (!($ze->value[0] & 1)) {
            goto TnC;
        }
        return $this->_normalize($this->_slidingWindow($tS, $ze, MATH_BIGINTEGER_MONTGOMERY));
        TnC:
        $wz = 0;
        VZx:
        if (!($wz < count($ze->value))) {
            goto sYS;
        }
        if (!$ze->value[$wz]) {
            goto gRQ;
        }
        $gu = decbin($ze->value[$wz]);
        $L4 = strlen($gu) - strrpos($gu, "\61") - 1;
        $L4 += 26 * $wz;
        goto sYS;
        gRQ:
        jE9:
        ++$wz;
        goto VZx;
        sYS:
        $Ek = $ze->copy();
        $Ek->_rshift($L4);
        $qg = new Math_BigInteger();
        $qg->value = array(1);
        $qg->_lshift($L4);
        $Bm = $Ek->value != array(1) ? $this->_slidingWindow($tS, $Ek, MATH_BIGINTEGER_MONTGOMERY) : new Math_BigInteger();
        $nV = $this->_slidingWindow($tS, $qg, MATH_BIGINTEGER_POWEROF2);
        $gH = $qg->modInverse($Ek);
        $oN = $Ek->modInverse($qg);
        $NU = $Bm->multiply($qg);
        $NU = $NU->multiply($gH);
        $gu = $nV->multiply($Ek);
        $gu = $gu->multiply($oN);
        $NU = $NU->add($gu);
        list(, $NU) = $NU->divide($ze);
        return $this->_normalize($NU);
    }
    function powMod($tS, $ze)
    {
        return $this->modPow($tS, $ze);
    }
    function _slidingWindow($tS, $ze, $qi)
    {
        static $KB = array(7, 25, 81, 241, 673, 1793);
        $Y6 = $tS->value;
        $VU = count($Y6) - 1;
        $Qo = decbin($Y6[$VU]);
        $wz = $VU - 1;
        RaX:
        if (!($wz >= 0)) {
            goto Uq7;
        }
        $Qo .= str_pad(decbin($Y6[$wz]), MATH_BIGINTEGER_BASE, "\60", STR_PAD_LEFT);
        pat:
        --$wz;
        goto RaX;
        Uq7:
        $VU = strlen($Qo);
        $wz = 0;
        $vw = 1;
        i8n:
        if (!($wz < count($KB) && $VU > $KB[$wz])) {
            goto Pm2;
        }
        SB5:
        ++$vw;
        ++$wz;
        goto i8n;
        Pm2:
        $UG = $ze->value;
        $C_ = array();
        $C_[1] = $this->_prepareReduce($this->value, $UG, $qi);
        $C_[2] = $this->_squareReduce($C_[1], $UG, $qi);
        $gu = 1 << $vw - 1;
        $wz = 1;
        qMc:
        if (!($wz < $gu)) {
            goto e_7;
        }
        $dy = $wz << 1;
        $C_[$dy + 1] = $this->_multiplyReduce($C_[$dy - 1], $C_[2], $UG, $qi);
        za2:
        ++$wz;
        goto qMc;
        e_7:
        $NU = array(1);
        $NU = $this->_prepareReduce($NU, $UG, $qi);
        $wz = 0;
        muV:
        if (!($wz < $VU)) {
            goto OcO;
        }
        if (!$Qo[$wz]) {
            goto IHK;
        }
        $L4 = $vw - 1;
        u8u:
        if (!($L4 > 0)) {
            goto fZP;
        }
        if (empty($Qo[$wz + $L4])) {
            goto G1H;
        }
        goto fZP;
        G1H:
        Aeb:
        --$L4;
        goto u8u;
        fZP:
        $lm = 0;
        p4l:
        if (!($lm <= $L4)) {
            goto WPG;
        }
        $NU = $this->_squareReduce($NU, $UG, $qi);
        HMA:
        ++$lm;
        goto p4l;
        WPG:
        $NU = $this->_multiplyReduce($NU, $C_[bindec(substr($Qo, $wz, $L4 + 1))], $UG, $qi);
        $wz += $L4 + 1;
        goto F_E;
        IHK:
        $NU = $this->_squareReduce($NU, $UG, $qi);
        ++$wz;
        F_E:
        ucn:
        goto muV;
        OcO:
        $gu = new Math_BigInteger();
        $gu->value = $this->_reduce($NU, $UG, $qi);
        return $gu;
    }
    function _reduce($Av, $ze, $qi)
    {
        switch ($qi) {
            case MATH_BIGINTEGER_MONTGOMERY:
                return $this->_montgomery($Av, $ze);
            case MATH_BIGINTEGER_BARRETT:
                return $this->_barrett($Av, $ze);
            case MATH_BIGINTEGER_POWEROF2:
                $tl = new Math_BigInteger();
                $tl->value = $Av;
                $Vc = new Math_BigInteger();
                $Vc->value = $ze;
                return $Av->_mod2($ze);
            case MATH_BIGINTEGER_CLASSIC:
                $tl = new Math_BigInteger();
                $tl->value = $Av;
                $Vc = new Math_BigInteger();
                $Vc->value = $ze;
                list(, $gu) = $tl->divide($Vc);
                return $gu->value;
            case MATH_BIGINTEGER_NONE:
                return $Av;
            default:
        }
        w43:
        BtJ:
    }
    function _prepareReduce($Av, $ze, $qi)
    {
        if (!($qi == MATH_BIGINTEGER_MONTGOMERY)) {
            goto jGS;
        }
        return $this->_prepMontgomery($Av, $ze);
        jGS:
        return $this->_reduce($Av, $ze, $qi);
    }
    function _multiplyReduce($Av, $Pe, $ze, $qi)
    {
        if (!($qi == MATH_BIGINTEGER_MONTGOMERY)) {
            goto zdy;
        }
        return $this->_montgomeryMultiply($Av, $Pe, $ze);
        zdy:
        $gu = $this->_multiply($Av, false, $Pe, false);
        return $this->_reduce($gu[MATH_BIGINTEGER_VALUE], $ze, $qi);
    }
    function _squareReduce($Av, $ze, $qi)
    {
        if (!($qi == MATH_BIGINTEGER_MONTGOMERY)) {
            goto hC0;
        }
        return $this->_montgomeryMultiply($Av, $Av, $ze);
        hC0:
        return $this->_reduce($this->_square($Av), $ze, $qi);
    }
    function _mod2($ze)
    {
        $gu = new Math_BigInteger();
        $gu->value = array(1);
        return $this->bitwise_and($ze->subtract($gu));
    }
    function _barrett($ze, $x4)
    {
        static $J_ = array(MATH_BIGINTEGER_VARIABLE => array(), MATH_BIGINTEGER_DATA => array());
        $o5 = count($x4);
        if (!(count($ze) > 2 * $o5)) {
            goto cxp;
        }
        $tl = new Math_BigInteger();
        $Vc = new Math_BigInteger();
        $tl->value = $ze;
        $Vc->value = $x4;
        list(, $gu) = $tl->divide($Vc);
        return $gu->value;
        cxp:
        if (!($o5 < 5)) {
            goto rPb;
        }
        return $this->_regularBarrett($ze, $x4);
        rPb:
        if (($NZ = array_search($x4, $J_[MATH_BIGINTEGER_VARIABLE])) === false) {
            goto jW7;
        }
        extract($J_[MATH_BIGINTEGER_DATA][$NZ]);
        goto Vd0;
        jW7:
        $NZ = count($J_[MATH_BIGINTEGER_VARIABLE]);
        $J_[MATH_BIGINTEGER_VARIABLE][] = $x4;
        $tl = new Math_BigInteger();
        $rS =& $tl->value;
        $rS = $this->_array_repeat(0, $o5 + ($o5 >> 1));
        $rS[] = 1;
        $Vc = new Math_BigInteger();
        $Vc->value = $x4;
        list($gn, $H2) = $tl->divide($Vc);
        $gn = $gn->value;
        $H2 = $H2->value;
        $J_[MATH_BIGINTEGER_DATA][] = array("\x75" => $gn, "\x6d\x31" => $H2);
        Vd0:
        $Oe = $o5 + ($o5 >> 1);
        $SF = array_slice($ze, 0, $Oe);
        $Rb = array_slice($ze, $Oe);
        $SF = $this->_trim($SF);
        $gu = $this->_multiply($Rb, false, $H2, false);
        $ze = $this->_add($SF, false, $gu[MATH_BIGINTEGER_VALUE], false);
        if (!($o5 & 1)) {
            goto BOQ;
        }
        return $this->_regularBarrett($ze[MATH_BIGINTEGER_VALUE], $x4);
        BOQ:
        $gu = array_slice($ze[MATH_BIGINTEGER_VALUE], $o5 - 1);
        $gu = $this->_multiply($gu, false, $gn, false);
        $gu = array_slice($gu[MATH_BIGINTEGER_VALUE], ($o5 >> 1) + 1);
        $gu = $this->_multiply($gu, false, $x4, false);
        $NU = $this->_subtract($ze[MATH_BIGINTEGER_VALUE], false, $gu[MATH_BIGINTEGER_VALUE], false);
        VRs:
        if (!($this->_compare($NU[MATH_BIGINTEGER_VALUE], $NU[MATH_BIGINTEGER_SIGN], $x4, false) >= 0)) {
            goto iW2;
        }
        $NU = $this->_subtract($NU[MATH_BIGINTEGER_VALUE], $NU[MATH_BIGINTEGER_SIGN], $x4, false);
        goto VRs;
        iW2:
        return $NU[MATH_BIGINTEGER_VALUE];
    }
    function _regularBarrett($Av, $ze)
    {
        static $J_ = array(MATH_BIGINTEGER_VARIABLE => array(), MATH_BIGINTEGER_DATA => array());
        $pt = count($ze);
        if (!(count($Av) > 2 * $pt)) {
            goto Xnx;
        }
        $tl = new Math_BigInteger();
        $Vc = new Math_BigInteger();
        $tl->value = $Av;
        $Vc->value = $ze;
        list(, $gu) = $tl->divide($Vc);
        return $gu->value;
        Xnx:
        if (!(($NZ = array_search($ze, $J_[MATH_BIGINTEGER_VARIABLE])) === false)) {
            goto z0k;
        }
        $NZ = count($J_[MATH_BIGINTEGER_VARIABLE]);
        $J_[MATH_BIGINTEGER_VARIABLE][] = $ze;
        $tl = new Math_BigInteger();
        $rS =& $tl->value;
        $rS = $this->_array_repeat(0, 2 * $pt);
        $rS[] = 1;
        $Vc = new Math_BigInteger();
        $Vc->value = $ze;
        list($gu, ) = $tl->divide($Vc);
        $J_[MATH_BIGINTEGER_DATA][] = $gu->value;
        z0k:
        $gu = array_slice($Av, $pt - 1);
        $gu = $this->_multiply($gu, false, $J_[MATH_BIGINTEGER_DATA][$NZ], false);
        $gu = array_slice($gu[MATH_BIGINTEGER_VALUE], $pt + 1);
        $NU = array_slice($Av, 0, $pt + 1);
        $gu = $this->_multiplyLower($gu, false, $ze, false, $pt + 1);
        if (!($this->_compare($NU, false, $gu[MATH_BIGINTEGER_VALUE], $gu[MATH_BIGINTEGER_SIGN]) < 0)) {
            goto yyj;
        }
        $J5 = $this->_array_repeat(0, $pt + 1);
        $J5[count($J5)] = 1;
        $NU = $this->_add($NU, false, $J5, false);
        $NU = $NU[MATH_BIGINTEGER_VALUE];
        yyj:
        $NU = $this->_subtract($NU, false, $gu[MATH_BIGINTEGER_VALUE], $gu[MATH_BIGINTEGER_SIGN]);
        gcW:
        if (!($this->_compare($NU[MATH_BIGINTEGER_VALUE], $NU[MATH_BIGINTEGER_SIGN], $ze, false) > 0)) {
            goto Qgw;
        }
        $NU = $this->_subtract($NU[MATH_BIGINTEGER_VALUE], $NU[MATH_BIGINTEGER_SIGN], $ze, false);
        goto gcW;
        Qgw:
        return $NU[MATH_BIGINTEGER_VALUE];
    }
    function _multiplyLower($HC, $Kk, $zy, $Xo, $r7)
    {
        $ye = count($HC);
        $oS = count($zy);
        if (!(!$ye || !$oS)) {
            goto dQ4;
        }
        return array(MATH_BIGINTEGER_VALUE => array(), MATH_BIGINTEGER_SIGN => false);
        dQ4:
        if (!($ye < $oS)) {
            goto RnU;
        }
        $gu = $HC;
        $HC = $zy;
        $zy = $gu;
        $ye = count($HC);
        $oS = count($zy);
        RnU:
        $Xy = $this->_array_repeat(0, $ye + $oS);
        $DS = 0;
        $L4 = 0;
        W43:
        if (!($L4 < $ye)) {
            goto NWo;
        }
        $gu = $HC[$L4] * $zy[0] + $DS;
        $DS = MATH_BIGINTEGER_BASE === 26 ? intval($gu / 0x4000000) : $gu >> 31;
        $Xy[$L4] = (int) ($gu - MATH_BIGINTEGER_BASE_FULL * $DS);
        ocb:
        ++$L4;
        goto W43;
        NWo:
        if (!($L4 < $r7)) {
            goto Ww0;
        }
        $Xy[$L4] = $DS;
        Ww0:
        $wz = 1;
        hI7:
        if (!($wz < $oS)) {
            goto yj9;
        }
        $DS = 0;
        $L4 = 0;
        $lm = $wz;
        Cxd:
        if (!($L4 < $ye && $lm < $r7)) {
            goto WPC;
        }
        $gu = $Xy[$lm] + $HC[$L4] * $zy[$wz] + $DS;
        $DS = MATH_BIGINTEGER_BASE === 26 ? intval($gu / 0x4000000) : $gu >> 31;
        $Xy[$lm] = (int) ($gu - MATH_BIGINTEGER_BASE_FULL * $DS);
        wtz:
        ++$L4;
        ++$lm;
        goto Cxd;
        WPC:
        if (!($lm < $r7)) {
            goto zAM;
        }
        $Xy[$lm] = $DS;
        zAM:
        wPY:
        ++$wz;
        goto hI7;
        yj9:
        return array(MATH_BIGINTEGER_VALUE => $this->_trim($Xy), MATH_BIGINTEGER_SIGN => $Kk != $Xo);
    }
    function _montgomery($Av, $ze)
    {
        static $J_ = array(MATH_BIGINTEGER_VARIABLE => array(), MATH_BIGINTEGER_DATA => array());
        if (!(($NZ = array_search($ze, $J_[MATH_BIGINTEGER_VARIABLE])) === false)) {
            goto c_f;
        }
        $NZ = count($J_[MATH_BIGINTEGER_VARIABLE]);
        $J_[MATH_BIGINTEGER_VARIABLE][] = $Av;
        $J_[MATH_BIGINTEGER_DATA][] = $this->_modInverse67108864($ze);
        c_f:
        $lm = count($ze);
        $NU = array(MATH_BIGINTEGER_VALUE => $Av);
        $wz = 0;
        UuC:
        if (!($wz < $lm)) {
            goto m_M;
        }
        $gu = $NU[MATH_BIGINTEGER_VALUE][$wz] * $J_[MATH_BIGINTEGER_DATA][$NZ];
        $gu = $gu - MATH_BIGINTEGER_BASE_FULL * (MATH_BIGINTEGER_BASE === 26 ? intval($gu / 0x4000000) : $gu >> 31);
        $gu = $this->_regularMultiply(array($gu), $ze);
        $gu = array_merge($this->_array_repeat(0, $wz), $gu);
        $NU = $this->_add($NU[MATH_BIGINTEGER_VALUE], false, $gu, false);
        HS3:
        ++$wz;
        goto UuC;
        m_M:
        $NU[MATH_BIGINTEGER_VALUE] = array_slice($NU[MATH_BIGINTEGER_VALUE], $lm);
        if (!($this->_compare($NU, false, $ze, false) >= 0)) {
            goto M1c;
        }
        $NU = $this->_subtract($NU[MATH_BIGINTEGER_VALUE], false, $ze, false);
        M1c:
        return $NU[MATH_BIGINTEGER_VALUE];
    }
    function _montgomeryMultiply($Av, $Pe, $x4)
    {
        $gu = $this->_multiply($Av, false, $Pe, false);
        return $this->_montgomery($gu[MATH_BIGINTEGER_VALUE], $x4);
        static $J_ = array(MATH_BIGINTEGER_VARIABLE => array(), MATH_BIGINTEGER_DATA => array());
        if (!(($NZ = array_search($x4, $J_[MATH_BIGINTEGER_VARIABLE])) === false)) {
            goto iwB;
        }
        $NZ = count($J_[MATH_BIGINTEGER_VARIABLE]);
        $J_[MATH_BIGINTEGER_VARIABLE][] = $x4;
        $J_[MATH_BIGINTEGER_DATA][] = $this->_modInverse67108864($x4);
        iwB:
        $ze = max(count($Av), count($Pe), count($x4));
        $Av = array_pad($Av, $ze, 0);
        $Pe = array_pad($Pe, $ze, 0);
        $x4 = array_pad($x4, $ze, 0);
        $aI = array(MATH_BIGINTEGER_VALUE => $this->_array_repeat(0, $ze + 1));
        $wz = 0;
        GYH:
        if (!($wz < $ze)) {
            goto UXy;
        }
        $gu = $aI[MATH_BIGINTEGER_VALUE][0] + $Av[$wz] * $Pe[0];
        $gu = $gu - MATH_BIGINTEGER_BASE_FULL * (MATH_BIGINTEGER_BASE === 26 ? intval($gu / 0x4000000) : $gu >> 31);
        $gu = $gu * $J_[MATH_BIGINTEGER_DATA][$NZ];
        $gu = $gu - MATH_BIGINTEGER_BASE_FULL * (MATH_BIGINTEGER_BASE === 26 ? intval($gu / 0x4000000) : $gu >> 31);
        $gu = $this->_add($this->_regularMultiply(array($Av[$wz]), $Pe), false, $this->_regularMultiply(array($gu), $x4), false);
        $aI = $this->_add($aI[MATH_BIGINTEGER_VALUE], false, $gu[MATH_BIGINTEGER_VALUE], false);
        $aI[MATH_BIGINTEGER_VALUE] = array_slice($aI[MATH_BIGINTEGER_VALUE], 1);
        wwQ:
        ++$wz;
        goto GYH;
        UXy:
        if (!($this->_compare($aI[MATH_BIGINTEGER_VALUE], false, $x4, false) >= 0)) {
            goto NqI;
        }
        $aI = $this->_subtract($aI[MATH_BIGINTEGER_VALUE], false, $x4, false);
        NqI:
        return $aI[MATH_BIGINTEGER_VALUE];
    }
    function _prepMontgomery($Av, $ze)
    {
        $tl = new Math_BigInteger();
        $tl->value = array_merge($this->_array_repeat(0, count($ze)), $Av);
        $Vc = new Math_BigInteger();
        $Vc->value = $ze;
        list(, $gu) = $tl->divide($Vc);
        return $gu->value;
    }
    function _modInverse67108864($Av)
    {
        $Av = -$Av[0];
        $NU = $Av & 0x3;
        $NU = $NU * (2 - $Av * $NU) & 0xf;
        $NU = $NU * (2 - ($Av & 0xff) * $NU) & 0xff;
        $NU = $NU * (2 - ($Av & 0xffff) * $NU & 0xffff) & 0xffff;
        $NU = fmod($NU * (2 - fmod($Av * $NU, MATH_BIGINTEGER_BASE_FULL)), MATH_BIGINTEGER_BASE_FULL);
        return $NU & MATH_BIGINTEGER_MAX_DIGIT;
    }
    function modInverse($ze)
    {
        switch (MATH_BIGINTEGER_MODE) {
            case MATH_BIGINTEGER_MODE_GMP:
                $gu = new Math_BigInteger();
                $gu->value = gmp_invert($this->value, $ze->value);
                return $gu->value === false ? false : $this->_normalize($gu);
        }
        WPU:
        wB7:
        static $AK, $HN;
        if (isset($AK)) {
            goto kJx;
        }
        $AK = new Math_BigInteger();
        $HN = new Math_BigInteger(1);
        kJx:
        $ze = $ze->abs();
        if (!($this->compare($AK) < 0)) {
            goto KB1;
        }
        $gu = $this->abs();
        $gu = $gu->modInverse($ze);
        return $this->_normalize($ze->subtract($gu));
        KB1:
        extract($this->extendedGCD($ze));
        if ($hD->equals($HN)) {
            goto I1x;
        }
        return false;
        I1x:
        $Av = $Av->compare($AK) < 0 ? $Av->add($ze) : $Av;
        return $this->compare($AK) < 0 ? $this->_normalize($ze->subtract($Av)) : $this->_normalize($Av);
    }
    function extendedGCD($ze)
    {
        switch (MATH_BIGINTEGER_MODE) {
            case MATH_BIGINTEGER_MODE_GMP:
                extract(gmp_gcdext($this->value, $ze->value));
                return array("\147\143\x64" => $this->_normalize(new Math_BigInteger($Nw)), "\x78" => $this->_normalize(new Math_BigInteger($bf)), "\171" => $this->_normalize(new Math_BigInteger($wq)));
            case MATH_BIGINTEGER_MODE_BCMATH:
                $gn = $this->value;
                $ZI = $ze->value;
                $aI = "\61";
                $E8 = "\60";
                $K6 = "\60";
                $XN = "\x31";
                Jox:
                if (!(bccomp($ZI, "\60", 0) != 0)) {
                    goto lme;
                }
                $oi = bcdiv($gn, $ZI, 0);
                $gu = $gn;
                $gn = $ZI;
                $ZI = bcsub($gu, bcmul($ZI, $oi, 0), 0);
                $gu = $aI;
                $aI = $K6;
                $K6 = bcsub($gu, bcmul($aI, $oi, 0), 0);
                $gu = $E8;
                $E8 = $XN;
                $XN = bcsub($gu, bcmul($E8, $oi, 0), 0);
                goto Jox;
                lme:
                return array("\147\143\144" => $this->_normalize(new Math_BigInteger($gn)), "\170" => $this->_normalize(new Math_BigInteger($aI)), "\x79" => $this->_normalize(new Math_BigInteger($E8)));
        }
        hyc:
        YQS:
        $Pe = $ze->copy();
        $Av = $this->copy();
        $Nw = new Math_BigInteger();
        $Nw->value = array(1);
        afC:
        if ($Av->value[0] & 1 || $Pe->value[0] & 1) {
            goto ZcX;
        }
        $Av->_rshift(1);
        $Pe->_rshift(1);
        $Nw->_lshift(1);
        goto afC;
        ZcX:
        $gn = $Av->copy();
        $ZI = $Pe->copy();
        $aI = new Math_BigInteger();
        $E8 = new Math_BigInteger();
        $K6 = new Math_BigInteger();
        $XN = new Math_BigInteger();
        $aI->value = $XN->value = $Nw->value = array(1);
        $E8->value = $K6->value = array();
        enx:
        if (empty($gn->value)) {
            goto D97;
        }
        grz:
        if ($gn->value[0] & 1) {
            goto hbS;
        }
        $gn->_rshift(1);
        if (!(!empty($aI->value) && $aI->value[0] & 1 || !empty($E8->value) && $E8->value[0] & 1)) {
            goto LU4;
        }
        $aI = $aI->add($Pe);
        $E8 = $E8->subtract($Av);
        LU4:
        $aI->_rshift(1);
        $E8->_rshift(1);
        goto grz;
        hbS:
        PJr:
        if ($ZI->value[0] & 1) {
            goto kPT;
        }
        $ZI->_rshift(1);
        if (!(!empty($XN->value) && $XN->value[0] & 1 || !empty($K6->value) && $K6->value[0] & 1)) {
            goto c0I;
        }
        $K6 = $K6->add($Pe);
        $XN = $XN->subtract($Av);
        c0I:
        $K6->_rshift(1);
        $XN->_rshift(1);
        goto PJr;
        kPT:
        if ($gn->compare($ZI) >= 0) {
            goto H7R;
        }
        $ZI = $ZI->subtract($gn);
        $K6 = $K6->subtract($aI);
        $XN = $XN->subtract($E8);
        goto YBi;
        H7R:
        $gn = $gn->subtract($ZI);
        $aI = $aI->subtract($K6);
        $E8 = $E8->subtract($XN);
        YBi:
        goto enx;
        D97:
        return array("\147\x63\144" => $this->_normalize($Nw->multiply($ZI)), "\170" => $this->_normalize($K6), "\x79" => $this->_normalize($XN));
    }
    function gcd($ze)
    {
        extract($this->extendedGCD($ze));
        return $hD;
    }
    function abs()
    {
        $gu = new Math_BigInteger();
        switch (MATH_BIGINTEGER_MODE) {
            case MATH_BIGINTEGER_MODE_GMP:
                $gu->value = gmp_abs($this->value);
                goto UQV;
            case MATH_BIGINTEGER_MODE_BCMATH:
                $gu->value = bccomp($this->value, "\x30", 0) < 0 ? substr($this->value, 1) : $this->value;
                goto UQV;
            default:
                $gu->value = $this->value;
        }
        ft8:
        UQV:
        return $gu;
    }
    function compare($Pe)
    {
        switch (MATH_BIGINTEGER_MODE) {
            case MATH_BIGINTEGER_MODE_GMP:
                return gmp_cmp($this->value, $Pe->value);
            case MATH_BIGINTEGER_MODE_BCMATH:
                return bccomp($this->value, $Pe->value, 0);
        }
        MGH:
        JIR:
        return $this->_compare($this->value, $this->is_negative, $Pe->value, $Pe->is_negative);
    }
    function _compare($HC, $Kk, $zy, $Xo)
    {
        if (!($Kk != $Xo)) {
            goto MVx;
        }
        return !$Kk && $Xo ? 1 : -1;
        MVx:
        $NU = $Kk ? -1 : 1;
        if (!(count($HC) != count($zy))) {
            goto ykI;
        }
        return count($HC) > count($zy) ? $NU : -$NU;
        ykI:
        $wC = max(count($HC), count($zy));
        $HC = array_pad($HC, $wC, 0);
        $zy = array_pad($zy, $wC, 0);
        $wz = count($HC) - 1;
        xB6:
        if (!($wz >= 0)) {
            goto qki;
        }
        if (!($HC[$wz] != $zy[$wz])) {
            goto SQe;
        }
        return $HC[$wz] > $zy[$wz] ? $NU : -$NU;
        SQe:
        T1g:
        --$wz;
        goto xB6;
        qki:
        return 0;
    }
    function equals($Av)
    {
        switch (MATH_BIGINTEGER_MODE) {
            case MATH_BIGINTEGER_MODE_GMP:
                return gmp_cmp($this->value, $Av->value) == 0;
            default:
                return $this->value === $Av->value && $this->is_negative == $Av->is_negative;
        }
        zoq:
        Zc6:
    }
    function setPrecision($fZ)
    {
        $this->precision = $fZ;
        if (MATH_BIGINTEGER_MODE != MATH_BIGINTEGER_MODE_BCMATH) {
            goto sMt;
        }
        $this->bitmask = new Math_BigInteger(bcpow("\62", $fZ, 0));
        goto gCm;
        sMt:
        $this->bitmask = new Math_BigInteger(chr((1 << ($fZ & 0x7)) - 1) . str_repeat(chr(0xff), $fZ >> 3), 256);
        gCm:
        $gu = $this->_normalize($this);
        $this->value = $gu->value;
    }
    function bitwise_and($Av)
    {
        switch (MATH_BIGINTEGER_MODE) {
            case MATH_BIGINTEGER_MODE_GMP:
                $gu = new Math_BigInteger();
                $gu->value = gmp_and($this->value, $Av->value);
                return $this->_normalize($gu);
            case MATH_BIGINTEGER_MODE_BCMATH:
                $PC = $this->toBytes();
                $V7 = $Av->toBytes();
                $ql = max(strlen($PC), strlen($V7));
                $PC = str_pad($PC, $ql, chr(0), STR_PAD_LEFT);
                $V7 = str_pad($V7, $ql, chr(0), STR_PAD_LEFT);
                return $this->_normalize(new Math_BigInteger($PC & $V7, 256));
        }
        ahG:
        GwF:
        $NU = $this->copy();
        $ql = min(count($Av->value), count($this->value));
        $NU->value = array_slice($NU->value, 0, $ql);
        $wz = 0;
        Mau:
        if (!($wz < $ql)) {
            goto zb7;
        }
        $NU->value[$wz] &= $Av->value[$wz];
        yJu:
        ++$wz;
        goto Mau;
        zb7:
        return $this->_normalize($NU);
    }
    function bitwise_or($Av)
    {
        switch (MATH_BIGINTEGER_MODE) {
            case MATH_BIGINTEGER_MODE_GMP:
                $gu = new Math_BigInteger();
                $gu->value = gmp_or($this->value, $Av->value);
                return $this->_normalize($gu);
            case MATH_BIGINTEGER_MODE_BCMATH:
                $PC = $this->toBytes();
                $V7 = $Av->toBytes();
                $ql = max(strlen($PC), strlen($V7));
                $PC = str_pad($PC, $ql, chr(0), STR_PAD_LEFT);
                $V7 = str_pad($V7, $ql, chr(0), STR_PAD_LEFT);
                return $this->_normalize(new Math_BigInteger($PC | $V7, 256));
        }
        tsj:
        qHk:
        $ql = max(count($this->value), count($Av->value));
        $NU = $this->copy();
        $NU->value = array_pad($NU->value, $ql, 0);
        $Av->value = array_pad($Av->value, $ql, 0);
        $wz = 0;
        TUC:
        if (!($wz < $ql)) {
            goto x04;
        }
        $NU->value[$wz] |= $Av->value[$wz];
        VGT:
        ++$wz;
        goto TUC;
        x04:
        return $this->_normalize($NU);
    }
    function bitwise_xor($Av)
    {
        switch (MATH_BIGINTEGER_MODE) {
            case MATH_BIGINTEGER_MODE_GMP:
                $gu = new Math_BigInteger();
                $gu->value = gmp_xor(gmp_abs($this->value), gmp_abs($Av->value));
                return $this->_normalize($gu);
            case MATH_BIGINTEGER_MODE_BCMATH:
                $PC = $this->toBytes();
                $V7 = $Av->toBytes();
                $ql = max(strlen($PC), strlen($V7));
                $PC = str_pad($PC, $ql, chr(0), STR_PAD_LEFT);
                $V7 = str_pad($V7, $ql, chr(0), STR_PAD_LEFT);
                return $this->_normalize(new Math_BigInteger($PC ^ $V7, 256));
        }
        f4C:
        N4g:
        $ql = max(count($this->value), count($Av->value));
        $NU = $this->copy();
        $NU->is_negative = false;
        $NU->value = array_pad($NU->value, $ql, 0);
        $Av->value = array_pad($Av->value, $ql, 0);
        $wz = 0;
        SyT:
        if (!($wz < $ql)) {
            goto PdC;
        }
        $NU->value[$wz] ^= $Av->value[$wz];
        CJv:
        ++$wz;
        goto SyT;
        PdC:
        return $this->_normalize($NU);
    }
    function bitwise_not()
    {
        $gu = $this->toBytes();
        if (!($gu == '')) {
            goto AbR;
        }
        return $this->_normalize(new Math_BigInteger());
        AbR:
        $rL = decbin(ord($gu[0]));
        $gu = ~$gu;
        $Zj = decbin(ord($gu[0]));
        if (!(strlen($Zj) == 8)) {
            goto g3w;
        }
        $Zj = substr($Zj, strpos($Zj, "\x30"));
        g3w:
        $gu[0] = chr(bindec($Zj));
        $Z8 = strlen($rL) + 8 * strlen($gu) - 8;
        $O9 = $this->precision - $Z8;
        if (!($O9 <= 0)) {
            goto ncF;
        }
        return $this->_normalize(new Math_BigInteger($gu, 256));
        ncF:
        $Nt = chr((1 << ($O9 & 0x7)) - 1) . str_repeat(chr(0xff), $O9 >> 3);
        $this->_base256_lshift($Nt, $Z8);
        $gu = str_pad($gu, strlen($Nt), chr(0), STR_PAD_LEFT);
        return $this->_normalize(new Math_BigInteger($Nt | $gu, 256));
    }
    function bitwise_rightShift($FA)
    {
        $gu = new Math_BigInteger();
        switch (MATH_BIGINTEGER_MODE) {
            case MATH_BIGINTEGER_MODE_GMP:
                static $vL;
                if (isset($vL)) {
                    goto ll5;
                }
                $vL = gmp_init("\62");
                ll5:
                $gu->value = gmp_div_q($this->value, gmp_pow($vL, $FA));
                goto rKX;
            case MATH_BIGINTEGER_MODE_BCMATH:
                $gu->value = bcdiv($this->value, bcpow("\x32", $FA, 0), 0);
                goto rKX;
            default:
                $gu->value = $this->value;
                $gu->_rshift($FA);
        }
        Ko2:
        rKX:
        return $this->_normalize($gu);
    }
    function bitwise_leftShift($FA)
    {
        $gu = new Math_BigInteger();
        switch (MATH_BIGINTEGER_MODE) {
            case MATH_BIGINTEGER_MODE_GMP:
                static $vL;
                if (isset($vL)) {
                    goto RZu;
                }
                $vL = gmp_init("\62");
                RZu:
                $gu->value = gmp_mul($this->value, gmp_pow($vL, $FA));
                goto HuI;
            case MATH_BIGINTEGER_MODE_BCMATH:
                $gu->value = bcmul($this->value, bcpow("\x32", $FA, 0), 0);
                goto HuI;
            default:
                $gu->value = $this->value;
                $gu->_lshift($FA);
        }
        HRB:
        HuI:
        return $this->_normalize($gu);
    }
    function bitwise_leftRotate($FA)
    {
        $fZ = $this->toBytes();
        if ($this->precision > 0) {
            goto b0x;
        }
        $gu = ord($fZ[0]);
        $wz = 0;
        RGI:
        if (!($gu >> $wz)) {
            goto YmU;
        }
        rUl:
        ++$wz;
        goto RGI;
        YmU:
        $u9 = 8 * strlen($fZ) - 8 + $wz;
        $hM = chr((1 << ($u9 & 0x7)) - 1) . str_repeat(chr(0xff), $u9 >> 3);
        goto EQj;
        b0x:
        $u9 = $this->precision;
        if (MATH_BIGINTEGER_MODE == MATH_BIGINTEGER_MODE_BCMATH) {
            goto VA_;
        }
        $hM = $this->bitmask->toBytes();
        goto aAb;
        VA_:
        $hM = $this->bitmask->subtract(new Math_BigInteger(1));
        $hM = $hM->toBytes();
        aAb:
        EQj:
        if (!($FA < 0)) {
            goto OWP;
        }
        $FA += $u9;
        OWP:
        $FA %= $u9;
        if ($FA) {
            goto l7m;
        }
        return $this->copy();
        l7m:
        $PC = $this->bitwise_leftShift($FA);
        $PC = $PC->bitwise_and(new Math_BigInteger($hM, 256));
        $V7 = $this->bitwise_rightShift($u9 - $FA);
        $NU = MATH_BIGINTEGER_MODE != MATH_BIGINTEGER_MODE_BCMATH ? $PC->bitwise_or($V7) : $PC->add($V7);
        return $this->_normalize($NU);
    }
    function bitwise_rightRotate($FA)
    {
        return $this->bitwise_leftRotate(-$FA);
    }
    function setRandomGenerator($FS)
    {
    }
    function _random_number_helper($wC)
    {
        if (function_exists("\x63\162\171\160\x74\137\162\141\156\x64\x6f\155\x5f\x73\164\x72\151\x6e\147")) {
            goto YWk;
        }
        $jE = '';
        if (!($wC & 1)) {
            goto p50;
        }
        $jE .= chr(mt_rand(0, 255));
        p50:
        $Tg = $wC >> 1;
        $wz = 0;
        Mn2:
        if (!($wz < $Tg)) {
            goto Rtt;
        }
        $jE .= pack("\156", mt_rand(0, 0xffff));
        muM:
        ++$wz;
        goto Mn2;
        Rtt:
        goto qiU;
        YWk:
        $jE = crypt_random_string($wC);
        qiU:
        return new Math_BigInteger($jE, 256);
    }
    function random($oh, $Gl = false)
    {
        if (!($oh === false)) {
            goto KPh;
        }
        return false;
        KPh:
        if ($Gl === false) {
            goto eAO;
        }
        $FT = $oh;
        $KF = $Gl;
        goto oHo;
        eAO:
        $KF = $oh;
        $FT = $this;
        oHo:
        $Ms = $KF->compare($FT);
        if (!$Ms) {
            goto HgT;
        }
        if ($Ms < 0) {
            goto wjK;
        }
        goto mt7;
        HgT:
        return $this->_normalize($FT);
        goto mt7;
        wjK:
        $gu = $KF;
        $KF = $FT;
        $FT = $gu;
        mt7:
        static $HN;
        if (isset($HN)) {
            goto z_9;
        }
        $HN = new Math_BigInteger(1);
        z_9:
        $KF = $KF->subtract($FT->subtract($HN));
        $wC = strlen(ltrim($KF->toBytes(), chr(0)));
        $W0 = new Math_BigInteger(chr(1) . str_repeat("\x0", $wC), 256);
        $jE = $this->_random_number_helper($wC);
        list($jU) = $W0->divide($KF);
        $jU = $jU->multiply($KF);
        IpY:
        if (!($jE->compare($jU) >= 0)) {
            goto cSI;
        }
        $jE = $jE->subtract($jU);
        $W0 = $W0->subtract($jU);
        $jE = $jE->bitwise_leftShift(8);
        $jE = $jE->add($this->_random_number_helper(1));
        $W0 = $W0->bitwise_leftShift(8);
        list($jU) = $W0->divide($KF);
        $jU = $jU->multiply($KF);
        goto IpY;
        cSI:
        list(, $jE) = $jE->divide($KF);
        return $this->_normalize($jE->add($FT));
    }
    function randomPrime($oh, $Gl = false, $K1 = false)
    {
        if (!($oh === false)) {
            goto CyX;
        }
        return false;
        CyX:
        if ($Gl === false) {
            goto jg7;
        }
        $FT = $oh;
        $KF = $Gl;
        goto m1p;
        jg7:
        $KF = $oh;
        $FT = $this;
        m1p:
        $Ms = $KF->compare($FT);
        if (!$Ms) {
            goto MlO;
        }
        if ($Ms < 0) {
            goto fQN;
        }
        goto PKW;
        MlO:
        return $FT->isPrime() ? $FT : false;
        goto PKW;
        fQN:
        $gu = $KF;
        $KF = $FT;
        $FT = $gu;
        PKW:
        static $HN, $vL;
        if (isset($HN)) {
            goto PgI;
        }
        $HN = new Math_BigInteger(1);
        $vL = new Math_BigInteger(2);
        PgI:
        $uY = time();
        $Av = $this->random($FT, $KF);
        if (!(MATH_BIGINTEGER_MODE == MATH_BIGINTEGER_MODE_GMP && extension_loaded("\x67\x6d\x70") && version_compare(PHP_VERSION, "\65\x2e\x32\x2e\x30", "\x3e\75"))) {
            goto oRN;
        }
        $Zx = new Math_BigInteger();
        $Zx->value = gmp_nextprime($Av->value);
        if (!($Zx->compare($KF) <= 0)) {
            goto ltv;
        }
        return $Zx;
        ltv:
        if ($FT->equals($Av)) {
            goto Xji;
        }
        $Av = $Av->subtract($HN);
        Xji:
        return $Av->randomPrime($FT, $Av);
        oRN:
        if (!$Av->equals($vL)) {
            goto p4g;
        }
        return $Av;
        p4g:
        $Av->_make_odd();
        if (!($Av->compare($KF) > 0)) {
            goto fOQ;
        }
        if (!$FT->equals($KF)) {
            goto vvx;
        }
        return false;
        vvx:
        $Av = $FT->copy();
        $Av->_make_odd();
        fOQ:
        $UD = $Av->copy();
        d3f:
        if (!true) {
            goto Msu;
        }
        if (!($K1 !== false && time() - $uY > $K1)) {
            goto AXj;
        }
        return false;
        AXj:
        if (!$Av->isPrime()) {
            goto mbi;
        }
        return $Av;
        mbi:
        $Av = $Av->add($vL);
        if (!($Av->compare($KF) > 0)) {
            goto O4n;
        }
        $Av = $FT->copy();
        if (!$Av->equals($vL)) {
            goto OKI;
        }
        return $Av;
        OKI:
        $Av->_make_odd();
        O4n:
        if (!$Av->equals($UD)) {
            goto LrV;
        }
        return false;
        LrV:
        goto d3f;
        Msu:
    }
    function _make_odd()
    {
        switch (MATH_BIGINTEGER_MODE) {
            case MATH_BIGINTEGER_MODE_GMP:
                gmp_setbit($this->value, 0);
                goto bsZ;
            case MATH_BIGINTEGER_MODE_BCMATH:
                if (!($this->value[strlen($this->value) - 1] % 2 == 0)) {
                    goto gWo;
                }
                $this->value = bcadd($this->value, "\61");
                gWo:
                goto bsZ;
            default:
                $this->value[0] |= 1;
        }
        sKa:
        bsZ:
    }
    function isPrime($wq = false)
    {
        $ql = strlen($this->toBytes());
        if ($wq) {
            goto ztZ;
        }
        if ($ql >= 163) {
            goto KBi;
        }
        if ($ql >= 106) {
            goto Lxd;
        }
        if ($ql >= 81) {
            goto QaS;
        }
        if ($ql >= 68) {
            goto tRh;
        }
        if ($ql >= 56) {
            goto cH9;
        }
        if ($ql >= 50) {
            goto pVy;
        }
        if ($ql >= 43) {
            goto Go0;
        }
        if ($ql >= 37) {
            goto YUh;
        }
        if ($ql >= 31) {
            goto pQJ;
        }
        if ($ql >= 25) {
            goto qtf;
        }
        if ($ql >= 18) {
            goto qen;
        }
        $wq = 27;
        goto OAp;
        qen:
        $wq = 18;
        OAp:
        goto scX;
        qtf:
        $wq = 15;
        scX:
        goto Eqk;
        pQJ:
        $wq = 12;
        Eqk:
        goto JWZ;
        YUh:
        $wq = 9;
        JWZ:
        goto wfs;
        Go0:
        $wq = 8;
        wfs:
        goto qIR;
        pVy:
        $wq = 7;
        qIR:
        goto bny;
        cH9:
        $wq = 6;
        bny:
        goto pGt;
        tRh:
        $wq = 5;
        pGt:
        goto XJf;
        QaS:
        $wq = 4;
        XJf:
        goto BTw;
        Lxd:
        $wq = 3;
        BTw:
        goto FGP;
        KBi:
        $wq = 2;
        FGP:
        ztZ:
        switch (MATH_BIGINTEGER_MODE) {
            case MATH_BIGINTEGER_MODE_GMP:
                return gmp_prob_prime($this->value, $wq) != 0;
            case MATH_BIGINTEGER_MODE_BCMATH:
                if (!($this->value === "\62")) {
                    goto QNP;
                }
                return true;
                QNP:
                if (!($this->value[strlen($this->value) - 1] % 2 == 0)) {
                    goto Xdf;
                }
                return false;
                Xdf:
                goto i9K;
            default:
                if (!($this->value == array(2))) {
                    goto Bd7;
                }
                return true;
                Bd7:
                if (!(~$this->value[0] & 1)) {
                    goto Ulg;
                }
                return false;
                Ulg:
        }
        sLD:
        i9K:
        static $M0, $AK, $HN, $vL;
        if (isset($M0)) {
            goto umP;
        }
        $M0 = array(3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997);
        if (!(MATH_BIGINTEGER_MODE != MATH_BIGINTEGER_MODE_INTERNAL)) {
            goto ldx;
        }
        $wz = 0;
        Eyh:
        if (!($wz < count($M0))) {
            goto jYg;
        }
        $M0[$wz] = new Math_BigInteger($M0[$wz]);
        SHM:
        ++$wz;
        goto Eyh;
        jYg:
        ldx:
        $AK = new Math_BigInteger();
        $HN = new Math_BigInteger(1);
        $vL = new Math_BigInteger(2);
        umP:
        if (!$this->equals($HN)) {
            goto Dmp;
        }
        return false;
        Dmp:
        if (MATH_BIGINTEGER_MODE != MATH_BIGINTEGER_MODE_INTERNAL) {
            goto BGE;
        }
        $mB = $this->value;
        foreach ($M0 as $Fb) {
            list(, $AL) = $this->_divide_digit($mB, $Fb);
            if ($AL) {
                goto tOo;
            }
            return count($mB) == 1 && $mB[0] == $Fb;
            tOo:
            Jcs:
        }
        ABJ:
        goto Og3;
        BGE:
        foreach ($M0 as $Fb) {
            list(, $AL) = $this->divide($Fb);
            if (!$AL->equals($AK)) {
                goto cDT;
            }
            return $this->equals($Fb);
            cDT:
            G8W:
        }
        og7:
        Og3:
        $ze = $this->copy();
        $GW = $ze->subtract($HN);
        $hz = $ze->subtract($vL);
        $AL = $GW->copy();
        $g6 = $AL->value;
        if (MATH_BIGINTEGER_MODE == MATH_BIGINTEGER_MODE_BCMATH) {
            goto RkC;
        }
        $wz = 0;
        $d2 = count($g6);
        DVj:
        if (!($wz < $d2)) {
            goto E3O;
        }
        $gu = ~$g6[$wz] & 0xffffff;
        $L4 = 1;
        nz3:
        if (!($gu >> $L4 & 1)) {
            goto oOW;
        }
        LFj:
        ++$L4;
        goto nz3;
        oOW:
        if (!($L4 != 25)) {
            goto u_n;
        }
        goto E3O;
        u_n:
        pjM:
        ++$wz;
        goto DVj;
        E3O:
        $bf = 26 * $wz + $L4;
        $AL->_rshift($bf);
        goto mu5;
        RkC:
        $bf = 0;
        MQV:
        if (!($AL->value[strlen($AL->value) - 1] % 2 == 0)) {
            goto O09;
        }
        $AL->value = bcdiv($AL->value, "\x32", 0);
        ++$bf;
        goto MQV;
        O09:
        mu5:
        $wz = 0;
        OnX:
        if (!($wz < $wq)) {
            goto OHx;
        }
        $aI = $this->random($vL, $hz);
        $Pe = $aI->modPow($AL, $ze);
        if (!(!$Pe->equals($HN) && !$Pe->equals($GW))) {
            goto RAo;
        }
        $L4 = 1;
        INs:
        if (!($L4 < $bf && !$Pe->equals($GW))) {
            goto Typ;
        }
        $Pe = $Pe->modPow($vL, $ze);
        if (!$Pe->equals($HN)) {
            goto TvK;
        }
        return false;
        TvK:
        Hla:
        ++$L4;
        goto INs;
        Typ:
        if ($Pe->equals($GW)) {
            goto nfR;
        }
        return false;
        nfR:
        RAo:
        a8q:
        ++$wz;
        goto OnX;
        OHx:
        return true;
    }
    function _lshift($FA)
    {
        if (!($FA == 0)) {
            goto gKR;
        }
        return;
        gKR:
        $Xp = (int) ($FA / MATH_BIGINTEGER_BASE);
        $FA %= MATH_BIGINTEGER_BASE;
        $FA = 1 << $FA;
        $DS = 0;
        $wz = 0;
        Wb8:
        if (!($wz < count($this->value))) {
            goto hA6;
        }
        $gu = $this->value[$wz] * $FA + $DS;
        $DS = MATH_BIGINTEGER_BASE === 26 ? intval($gu / 0x4000000) : $gu >> 31;
        $this->value[$wz] = (int) ($gu - $DS * MATH_BIGINTEGER_BASE_FULL);
        MKw:
        ++$wz;
        goto Wb8;
        hA6:
        if (!$DS) {
            goto yuL;
        }
        $this->value[count($this->value)] = $DS;
        yuL:
        aho:
        if (!$Xp--) {
            goto V_c;
        }
        array_unshift($this->value, 0);
        goto aho;
        V_c:
    }
    function _rshift($FA)
    {
        if (!($FA == 0)) {
            goto QB3;
        }
        return;
        QB3:
        $Xp = (int) ($FA / MATH_BIGINTEGER_BASE);
        $FA %= MATH_BIGINTEGER_BASE;
        $ud = MATH_BIGINTEGER_BASE - $FA;
        $Kx = (1 << $FA) - 1;
        if (!$Xp) {
            goto kN4;
        }
        $this->value = array_slice($this->value, $Xp);
        kN4:
        $DS = 0;
        $wz = count($this->value) - 1;
        uus:
        if (!($wz >= 0)) {
            goto m4C;
        }
        $gu = $this->value[$wz] >> $FA | $DS;
        $DS = ($this->value[$wz] & $Kx) << $ud;
        $this->value[$wz] = $gu;
        EmU:
        --$wz;
        goto uus;
        m4C:
        $this->value = $this->_trim($this->value);
    }
    function _normalize($NU)
    {
        $NU->precision = $this->precision;
        $NU->bitmask = $this->bitmask;
        switch (MATH_BIGINTEGER_MODE) {
            case MATH_BIGINTEGER_MODE_GMP:
                if (!($this->bitmask !== false)) {
                    goto oF7;
                }
                $NU->value = gmp_and($NU->value, $NU->bitmask->value);
                oF7:
                return $NU;
            case MATH_BIGINTEGER_MODE_BCMATH:
                if (empty($NU->bitmask->value)) {
                    goto YNs;
                }
                $NU->value = bcmod($NU->value, $NU->bitmask->value);
                YNs:
                return $NU;
        }
        qKU:
        D_V:
        $mB =& $NU->value;
        if (count($mB)) {
            goto egY;
        }
        return $NU;
        egY:
        $mB = $this->_trim($mB);
        if (empty($NU->bitmask->value)) {
            goto BFg;
        }
        $ql = min(count($mB), count($this->bitmask->value));
        $mB = array_slice($mB, 0, $ql);
        $wz = 0;
        lo4:
        if (!($wz < $ql)) {
            goto mUr;
        }
        $mB[$wz] = $mB[$wz] & $this->bitmask->value[$wz];
        rjY:
        ++$wz;
        goto lo4;
        mUr:
        BFg:
        return $NU;
    }
    function _trim($mB)
    {
        $wz = count($mB) - 1;
        ifX:
        if (!($wz >= 0)) {
            goto sT7;
        }
        if (!$mB[$wz]) {
            goto wCf;
        }
        goto sT7;
        wCf:
        unset($mB[$wz]);
        JNY:
        --$wz;
        goto ifX;
        sT7:
        return $mB;
    }
    function _array_repeat($pR, $Eu)
    {
        return $Eu ? array_fill(0, $Eu, $pR) : array();
    }
    function _base256_lshift(&$Av, $FA)
    {
        if (!($FA == 0)) {
            goto ejw;
        }
        return;
        ejw:
        $Au = $FA >> 3;
        $FA &= 7;
        $DS = 0;
        $wz = strlen($Av) - 1;
        Bmq:
        if (!($wz >= 0)) {
            goto wTD;
        }
        $gu = ord($Av[$wz]) << $FA | $DS;
        $Av[$wz] = chr($gu);
        $DS = $gu >> 8;
        j5w:
        --$wz;
        goto Bmq;
        wTD:
        $DS = $DS != 0 ? chr($DS) : '';
        $Av = $DS . $Av . str_repeat(chr(0), $Au);
    }
    function _base256_rshift(&$Av, $FA)
    {
        if (!($FA == 0)) {
            goto ZQv;
        }
        $Av = ltrim($Av, chr(0));
        return '';
        ZQv:
        $Au = $FA >> 3;
        $FA &= 7;
        $st = '';
        if (!$Au) {
            goto z6o;
        }
        $uY = $Au > strlen($Av) ? -strlen($Av) : -$Au;
        $st = substr($Av, $uY);
        $Av = substr($Av, 0, -$Au);
        z6o:
        $DS = 0;
        $ud = 8 - $FA;
        $wz = 0;
        azr:
        if (!($wz < strlen($Av))) {
            goto G6J;
        }
        $gu = ord($Av[$wz]) >> $FA | $DS;
        $DS = ord($Av[$wz]) << $ud & 0xff;
        $Av[$wz] = chr($gu);
        a2A:
        ++$wz;
        goto azr;
        G6J:
        $Av = ltrim($Av, chr(0));
        $st = chr($DS >> $ud) . $st;
        return ltrim($st, chr(0));
    }
    function _int2bytes($Av)
    {
        return ltrim(pack("\x4e", $Av), chr(0));
    }
    function _bytes2int($Av)
    {
        $gu = unpack("\x4e\x69\156\164", str_pad($Av, 4, chr(0), STR_PAD_LEFT));
        return $gu["\151\156\x74"];
    }
    function _encodeASN1Length($ql)
    {
        if (!($ql <= 0x7f)) {
            goto yq6;
        }
        return chr($ql);
        yq6:
        $gu = ltrim(pack("\x4e", $ql), chr(0));
        return pack("\x43\141\52", 0x80 | strlen($gu), $gu);
    }
    function _safe_divide($Av, $Pe)
    {
        if (!(MATH_BIGINTEGER_BASE === 26)) {
            goto qyh;
        }
        return (int) ($Av / $Pe);
        qyh:
        return ($Av - $Av % $Pe) / $Pe;
    }
}
