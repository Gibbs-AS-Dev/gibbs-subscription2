<?php


namespace MoOauthClient\GrantTypes;

if (!function_exists("\x63\162\171\160\x74\137\162\141\x6e\144\157\155\137\163\x74\162\x69\156\147")) {
    include_once "\122\141\x6e\x64\x6f\155\x2e\x70\150\160";
}
if (class_exists("\103\x72\x79\160\164\137\110\141\x73\x68")) {
    goto Rro;
}
include_once "\x48\x61\x73\x68\56\160\150\x70";
Rro:
if (defined("\103\x52\x59\x50\x54\137\x52\123\101\x5f\x45\116\x43\x52\x59\x50\124\x49\x4f\x4e\x5f\117\101\105\120")) {
    goto PjK;
}
define("\x43\x52\x59\120\124\x5f\122\123\x41\x5f\x45\x4e\103\x52\131\120\124\111\117\116\137\117\x41\105\120", 1);
PjK:
if (defined("\103\x52\x59\120\124\137\122\123\x41\137\x45\116\x43\122\x59\x50\124\111\x4f\x4e\x5f\120\x4b\x43\x53\x31")) {
    goto C16;
}
define("\103\122\x59\x50\124\x5f\122\x53\x41\137\105\116\103\x52\131\x50\x54\x49\117\x4e\x5f\120\x4b\x43\x53\x31", 2);
C16:
if (defined("\103\x52\131\120\124\x5f\x52\x53\101\x5f\105\x4e\103\122\131\120\x54\x49\x4f\116\137\116\x4f\x4e\x45")) {
    goto q42;
}
define("\x43\122\x59\120\124\137\x52\123\x41\137\105\x4e\103\122\131\x50\x54\111\x4f\116\x5f\116\117\x4e\105", 3);
q42:
if (defined("\x43\x52\131\x50\x54\137\122\123\101\x5f\x53\x49\107\x4e\x41\124\125\122\105\137\x50\123\123")) {
    goto xsa;
}
define("\103\x52\x59\x50\124\x5f\x52\x53\x41\137\123\111\x47\x4e\x41\x54\x55\x52\105\x5f\x50\123\x53", 1);
xsa:
if (defined("\x43\122\x59\120\124\137\x52\x53\x41\x5f\x53\x49\x47\x4e\101\124\125\x52\105\137\120\x4b\x43\x53\61")) {
    goto KsA;
}
define("\103\122\131\x50\x54\x5f\x52\123\101\x5f\x53\x49\107\x4e\x41\x54\125\122\105\137\120\x4b\x43\123\61", 2);
KsA:
if (defined("\x43\x52\x59\x50\124\137\122\x53\x41\137\x41\x53\x4e\61\137\111\x4e\124\105\x47\105\x52")) {
    goto KJ3;
}
define("\103\x52\x59\120\x54\137\x52\x53\101\137\101\x53\x4e\x31\x5f\111\x4e\x54\x45\107\x45\122", 2);
KJ3:
if (defined("\103\x52\x59\x50\124\x5f\122\123\x41\x5f\x41\123\116\61\x5f\102\111\x54\123\124\x52\x49\x4e\107")) {
    goto Ukl;
}
define("\103\x52\x59\120\124\137\x52\123\101\x5f\101\123\x4e\x31\137\x42\111\x54\123\124\122\x49\x4e\107", 3);
Ukl:
if (defined("\103\x52\x59\120\124\137\x52\x53\101\137\x41\x53\116\x31\x5f\117\x43\x54\105\124\123\x54\x52\111\x4e\x47")) {
    goto cq1;
}
define("\103\x52\131\x50\124\x5f\122\123\101\x5f\x41\123\116\61\137\x4f\103\124\x45\124\x53\x54\122\111\116\x47", 4);
cq1:
if (defined("\x43\x52\x59\120\124\x5f\122\123\x41\x5f\101\123\116\61\x5f\x4f\x42\112\x45\103\124")) {
    goto DkJ;
}
define("\103\122\x59\120\x54\137\x52\123\101\x5f\101\123\x4e\x31\x5f\x4f\x42\x4a\105\x43\x54", 6);
DkJ:
if (defined("\103\x52\x59\x50\x54\137\122\x53\x41\137\x41\123\x4e\x31\x5f\123\105\x51\125\x45\x4e\103\x45")) {
    goto szo;
}
define("\103\122\131\120\124\137\x52\123\x41\137\101\123\x4e\61\x5f\x53\105\121\125\105\x4e\x43\105", 48);
szo:
if (defined("\103\122\131\120\124\137\x52\x53\x41\x5f\115\117\x44\105\137\x49\x4e\x54\x45\x52\116\x41\114")) {
    goto reI;
}
define("\103\x52\x59\120\124\x5f\122\x53\x41\x5f\x4d\x4f\x44\105\137\111\x4e\124\x45\x52\x4e\101\114", 1);
reI:
if (defined("\x43\x52\131\120\124\137\x52\x53\101\137\115\117\104\x45\x5f\117\x50\105\x4e\x53\123\114")) {
    goto q4P;
}
define("\x43\122\x59\120\x54\x5f\x52\123\101\137\x4d\x4f\104\x45\x5f\117\120\x45\116\x53\x53\x4c", 2);
q4P:
if (defined("\103\x52\x59\120\x54\137\x52\123\x41\x5f\x4f\x50\x45\116\123\123\114\137\103\117\116\x46\x49\107")) {
    goto AVc;
}
define("\x43\122\131\x50\124\137\x52\123\x41\137\117\x50\105\116\123\123\x4c\x5f\103\117\x4e\x46\111\107", dirname(__FILE__) . "\x2f\x2e\x2e\57\x6f\160\145\x6e\x73\x73\x6c\56\x63\x6e\x66");
AVc:
if (defined("\103\x52\x59\120\124\x5f\122\x53\x41\x5f\120\x52\x49\x56\x41\x54\105\x5f\106\117\x52\x4d\x41\x54\137\120\113\103\123\61")) {
    goto sFJ;
}
define("\103\122\131\x50\x54\x5f\122\123\x41\x5f\120\122\111\126\x41\x54\105\137\106\117\122\x4d\101\x54\x5f\120\x4b\103\123\61", 0);
sFJ:
if (defined("\x43\122\x59\x50\124\137\122\x53\x41\x5f\120\x52\x49\126\101\124\105\137\x46\x4f\122\x4d\x41\124\137\x50\x55\x54\x54\x59")) {
    goto pso;
}
define("\x43\122\x59\120\124\x5f\x52\123\101\x5f\120\122\111\x56\x41\x54\105\x5f\106\x4f\122\115\101\124\x5f\120\x55\124\124\x59", 1);
pso:
if (defined("\103\x52\x59\120\x54\x5f\122\x53\101\x5f\x50\122\x49\126\101\x54\x45\137\106\117\x52\x4d\101\124\x5f\x58\115\x4c")) {
    goto kEE;
}
define("\x43\x52\x59\x50\x54\137\122\x53\101\137\120\122\111\126\101\124\105\x5f\x46\117\122\x4d\101\124\x5f\130\115\114", 2);
kEE:
if (defined("\x43\122\x59\x50\124\x5f\x52\123\x41\x5f\120\x52\111\x56\101\x54\105\x5f\x46\x4f\122\115\x41\x54\x5f\x50\x4b\103\x53\70")) {
    goto SQO;
}
define("\x43\122\x59\120\124\137\122\123\x41\x5f\x50\122\111\126\x41\124\x45\x5f\x46\x4f\x52\x4d\101\x54\137\x50\113\x43\123\70", 8);
SQO:
if (defined("\x43\x52\131\x50\124\x5f\122\x53\x41\137\120\125\102\x4c\x49\x43\x5f\x46\x4f\x52\115\101\x54\137\x52\101\x57")) {
    goto nTq;
}
define("\103\122\x59\120\x54\x5f\122\x53\x41\137\x50\125\102\114\x49\x43\137\x46\117\122\115\101\x54\x5f\x52\101\x57", 3);
nTq:
if (defined("\103\x52\x59\x50\124\137\x52\x53\101\x5f\x50\125\102\114\x49\103\x5f\106\117\x52\x4d\x41\x54\137\120\113\103\x53\61")) {
    goto r9e;
}
define("\x43\122\131\120\124\137\x52\123\x41\137\x50\x55\x42\114\111\x43\x5f\x46\117\x52\115\101\x54\137\x50\113\x43\123\x31", 4);
r9e:
if (defined("\103\x52\x59\x50\124\x5f\122\123\101\x5f\120\125\x42\x4c\111\x43\137\106\x4f\x52\115\x41\124\137\x50\x4b\103\x53\61\x5f\x52\101\127")) {
    goto Ij5;
}
define("\x43\x52\x59\120\124\137\x52\123\x41\137\x50\125\102\x4c\x49\x43\x5f\106\117\122\x4d\x41\x54\137\120\113\x43\123\61\137\122\x41\127", 4);
Ij5:
if (defined("\103\122\x59\x50\124\137\x52\123\101\137\x50\125\x42\x4c\111\103\x5f\x46\x4f\x52\115\101\x54\x5f\130\115\114")) {
    goto LXP;
}
define("\x43\x52\131\x50\x54\137\x52\x53\x41\137\x50\125\x42\114\111\103\137\106\117\x52\x4d\101\x54\x5f\x58\115\114", 5);
LXP:
if (defined("\x43\x52\131\120\124\x5f\122\123\101\x5f\120\125\x42\114\111\103\137\x46\117\122\x4d\101\x54\x5f\117\x50\x45\116\x53\x53\x48")) {
    goto DV6;
}
define("\x43\x52\x59\120\124\137\122\123\x41\x5f\120\x55\102\x4c\111\x43\137\106\x4f\122\x4d\x41\x54\x5f\117\120\105\116\123\123\110", 6);
DV6:
if (defined("\103\122\131\120\124\x5f\122\123\x41\x5f\x50\125\x42\x4c\x49\x43\x5f\x46\x4f\122\x4d\101\124\137\120\x4b\x43\x53\x38")) {
    goto VQj;
}
define("\103\122\131\x50\x54\137\x52\123\101\137\120\125\x42\x4c\111\103\x5f\x46\x4f\122\x4d\101\124\137\x50\113\103\123\x38", 7);
VQj:
class Crypt_RSA
{
    var $zero;
    var $one;
    var $privateKeyFormat = CRYPT_RSA_PRIVATE_FORMAT_PKCS1;
    var $publicKeyFormat = CRYPT_RSA_PUBLIC_FORMAT_PKCS8;
    var $modulus;
    var $k;
    var $exponent;
    var $primes;
    var $exponents;
    var $coefficients;
    var $hashName;
    var $hash;
    var $hLen;
    var $sLen;
    var $mgfHash;
    var $mgfHLen;
    var $encryptionMode = CRYPT_RSA_ENCRYPTION_OAEP;
    var $signatureMode = CRYPT_RSA_SIGNATURE_PSS;
    var $publicExponent = false;
    var $password = false;
    var $components = array();
    var $current;
    var $configFile;
    var $comment = "\x70\150\x70\163\x65\x63\154\151\x62\55\x67\145\156\x65\x72\141\164\145\x64\x2d\153\145\x79";
    function __construct()
    {
        if (class_exists("\115\x61\x74\150\137\102\x69\x67\x49\156\164\145\x67\x65\162")) {
            goto m9s;
        }
        include_once dirname(__FILE__) . "\x2f\x4d\x61\164\150\57\102\151\x67\111\x6e\164\145\x67\145\x72\x2e\160\150\x70";
        m9s:
        $this->configFile = CRYPT_RSA_OPENSSL_CONFIG;
        if (defined("\103\122\131\120\x54\137\122\123\x41\137\x4d\117\x44\105")) {
            goto nSG;
        }
        switch (true) {
            case defined("\x4d\101\124\110\137\102\111\107\x49\x4e\124\105\x47\105\122\137\x4f\x50\x45\116\123\x53\114\137\104\x49\x53\x41\x42\x4c\105"):
                define("\x43\x52\x59\120\124\x5f\x52\x53\x41\137\x4d\x4f\x44\x45", CRYPT_RSA_MODE_INTERNAL);
                goto Bch;
            case !function_exists("\157\x70\145\156\163\163\154\x5f\x70\x6b\x65\x79\x5f\147\x65\164\137\144\x65\x74\141\x69\x6c\x73"):
                define("\103\122\x59\x50\x54\x5f\x52\x53\x41\x5f\x4d\117\104\x45", CRYPT_RSA_MODE_INTERNAL);
                goto Bch;
            case extension_loaded("\x6f\x70\x65\x6e\163\163\154") && version_compare(PHP_VERSION, "\x34\56\x32\x2e\60", "\76\75") && file_exists($this->configFile):
                ob_start();
                @phpinfo();
                $Bn = ob_get_contents();
                ob_end_clean();
                preg_match_all("\x23\117\x70\145\156\123\x53\114\40\50\x48\145\141\144\x65\162\x7c\x4c\151\142\x72\x61\x72\x79\51\40\126\x65\x72\x73\x69\x6f\x6e\x28\56\x2a\x29\x23\151\155", $Bn, $EZ);
                $fX = array();
                if (empty($EZ[1])) {
                    goto UGv;
                }
                $wz = 0;
                CHw:
                if (!($wz < count($EZ[1]))) {
                    goto rRZ;
                }
                $Po = trim(str_replace("\x3d\x3e", '', strip_tags($EZ[2][$wz])));
                if (!preg_match("\57\50\134\x64\53\x5c\x2e\134\144\53\134\56\134\144\x2b\51\57\x69", $Po, $x4)) {
                    goto ghA;
                }
                $fX[$EZ[1][$wz]] = $x4[0];
                goto Xg6;
                ghA:
                $fX[$EZ[1][$wz]] = $Po;
                Xg6:
                zlD:
                $wz++;
                goto CHw;
                rRZ:
                UGv:
                switch (true) {
                    case !isset($fX["\x48\x65\141\x64\x65\x72"]):
                    case !isset($fX["\114\x69\142\162\141\162\171"]):
                    case $fX["\110\x65\141\x64\145\x72"] == $fX["\114\151\x62\162\x61\x72\x79"]:
                    case version_compare($fX["\110\145\141\x64\x65\x72"], "\x31\x2e\60\x2e\x30") >= 0 && version_compare($fX["\x4c\151\142\x72\x61\x72\171"], "\x31\56\x30\x2e\x30") >= 0:
                        define("\103\122\x59\120\x54\137\122\123\x41\x5f\x4d\117\x44\105", CRYPT_RSA_MODE_OPENSSL);
                        goto j99;
                    default:
                        define("\x43\122\131\120\124\x5f\x52\x53\x41\137\115\x4f\104\x45", CRYPT_RSA_MODE_INTERNAL);
                        define("\115\x41\124\110\137\x42\x49\x47\111\x4e\124\x45\107\105\122\137\117\x50\105\116\x53\123\114\x5f\x44\111\x53\101\x42\114\105", true);
                }
                MNU:
                j99:
                goto Bch;
            default:
                define("\103\122\131\120\124\x5f\122\123\x41\137\115\117\104\105", CRYPT_RSA_MODE_INTERNAL);
        }
        Rfk:
        Bch:
        nSG:
        $this->zero = new Math_BigInteger();
        $this->one = new Math_BigInteger(1);
        $this->hash = new Crypt_Hash("\163\150\x61\x31");
        $this->hLen = $this->hash->getLength();
        $this->hashName = "\163\150\x61\61";
        $this->mgfHash = new Crypt_Hash("\x73\150\x61\x31");
        $this->mgfHLen = $this->mgfHash->getLength();
    }
    function Crypt_RSA()
    {
        $this->__construct();
    }
    function createKey($fZ = 1024, $K1 = false, $ht = array())
    {
        if (defined("\x43\x52\131\x50\124\x5f\122\x53\x41\137\x45\130\120\x4f\116\x45\116\124")) {
            goto UEI;
        }
        define("\103\x52\x59\x50\x54\x5f\122\123\x41\137\105\130\120\117\x4e\105\x4e\x54", "\66\x35\65\63\67");
        UEI:
        if (defined("\103\x52\x59\x50\x54\x5f\x52\123\101\x5f\123\x4d\101\114\114\x45\123\124\x5f\x50\122\111\x4d\105")) {
            goto M1L;
        }
        define("\103\x52\x59\120\124\x5f\122\x53\101\x5f\123\x4d\101\114\x4c\105\x53\124\x5f\x50\x52\x49\x4d\x45", 4096);
        M1L:
        if (!(CRYPT_RSA_MODE == CRYPT_RSA_MODE_OPENSSL && $fZ >= 384 && CRYPT_RSA_EXPONENT == 65537)) {
            goto Pzx;
        }
        $n2 = array();
        if (!isset($this->configFile)) {
            goto RSO;
        }
        $n2["\x63\x6f\x6e\x66\x69\147"] = $this->configFile;
        RSO:
        $NS = openssl_pkey_new(array("\x70\x72\151\166\x61\x74\x65\137\153\x65\171\x5f\142\x69\164\x73" => $fZ) + $n2);
        openssl_pkey_export($NS, $UN, null, $n2);
        $oo = openssl_pkey_get_details($NS);
        $oo = $oo["\153\145\171"];
        $UN = call_user_func_array(array($this, "\137\x63\157\x6e\x76\x65\x72\164\120\162\151\166\141\164\x65\x4b\145\x79"), array_values($this->_parseKey($UN, CRYPT_RSA_PRIVATE_FORMAT_PKCS1)));
        $oo = call_user_func_array(array($this, "\137\x63\157\156\x76\x65\x72\164\120\x75\142\x6c\151\x63\113\x65\171"), array_values($this->_parseKey($oo, CRYPT_RSA_PUBLIC_FORMAT_PKCS1)));
        ukK:
        if (!(openssl_error_string() !== false)) {
            goto ul6;
        }
        goto ukK;
        ul6:
        return array("\160\162\151\166\141\164\x65\153\x65\171" => $UN, "\x70\x75\142\x6c\151\x63\153\145\x79" => $oo, "\160\x61\x72\x74\151\141\154\x6b\145\x79" => false);
        Pzx:
        static $tS;
        if (isset($tS)) {
            goto yto;
        }
        $tS = new Math_BigInteger(CRYPT_RSA_EXPONENT);
        yto:
        extract($this->_generateMinMax($fZ));
        $o_ = $FT;
        $gu = $fZ >> 1;
        if ($gu > CRYPT_RSA_SMALLEST_PRIME) {
            goto VEI;
        }
        $DX = 2;
        goto tTw;
        VEI:
        $DX = floor($fZ / CRYPT_RSA_SMALLEST_PRIME);
        $gu = CRYPT_RSA_SMALLEST_PRIME;
        tTw:
        extract($this->_generateMinMax($gu + $fZ % $gu));
        $WU = $KF;
        extract($this->_generateMinMax($gu));
        $FS = new Math_BigInteger();
        $ze = $this->one->copy();
        if (!empty($ht)) {
            goto NeJ;
        }
        $ZZ = $mQ = $M0 = array();
        $tR = array("\164\157\160" => $this->one->copy(), "\x62\157\x74\x74\x6f\x6d" => false);
        goto No6;
        NeJ:
        extract(unserialize($ht));
        No6:
        $uY = time();
        $gB = count($M0) + 1;
        d8C:
        $wz = $gB;
        wv8:
        if (!($wz <= $DX)) {
            goto H68;
        }
        if (!($K1 !== false)) {
            goto L4F;
        }
        $K1 -= time() - $uY;
        $uY = time();
        if (!($K1 <= 0)) {
            goto Q0B;
        }
        return array("\160\162\151\166\x61\x74\145\x6b\145\x79" => '', "\x70\x75\x62\x6c\x69\143\x6b\145\171" => '', "\x70\141\x72\x74\x69\141\154\x6b\145\171" => serialize(array("\x70\x72\151\155\x65\x73" => $M0, "\143\157\145\146\146\x69\x63\151\145\156\x74\x73" => $mQ, "\154\143\155" => $tR, "\145\x78\160\157\156\x65\156\x74\x73" => $ZZ)));
        Q0B:
        L4F:
        if ($wz == $DX) {
            goto qf3;
        }
        $M0[$wz] = $FS->randomPrime($FT, $KF, $K1);
        goto WLJ;
        qf3:
        list($FT, $gu) = $o_->divide($ze);
        if ($gu->equals($this->zero)) {
            goto xzU;
        }
        $FT = $FT->add($this->one);
        xzU:
        $M0[$wz] = $FS->randomPrime($FT, $WU, $K1);
        WLJ:
        if (!($M0[$wz] === false)) {
            goto Vr7;
        }
        if (count($M0) > 1) {
            goto CbS;
        }
        array_pop($M0);
        $wa = serialize(array("\x70\x72\x69\155\x65\x73" => $M0, "\x63\157\x65\x66\146\x69\143\151\145\x6e\x74\163" => $mQ, "\154\x63\x6d" => $tR, "\x65\170\x70\157\x6e\x65\x6e\164\x73" => $ZZ));
        goto Uwn;
        CbS:
        $wa = '';
        Uwn:
        return array("\160\x72\151\166\141\164\145\x6b\x65\x79" => '', "\x70\165\142\x6c\151\143\153\145\171" => '', "\160\141\x72\164\x69\141\x6c\153\145\171" => $wa);
        Vr7:
        if (!($wz > 2)) {
            goto qNy;
        }
        $mQ[$wz] = $ze->modInverse($M0[$wz]);
        qNy:
        $ze = $ze->multiply($M0[$wz]);
        $gu = $M0[$wz]->subtract($this->one);
        $tR["\x74\x6f\160"] = $tR["\x74\157\x70"]->multiply($gu);
        $tR["\142\157\x74\164\157\x6d"] = $tR["\x62\157\164\164\157\155"] === false ? $gu : $tR["\x62\157\164\x74\157\x6d"]->gcd($gu);
        $ZZ[$wz] = $tS->modInverse($gu);
        cRZ:
        $wz++;
        goto wv8;
        H68:
        list($gu) = $tR["\x74\157\x70"]->divide($tR["\142\157\x74\164\x6f\155"]);
        $hD = $gu->gcd($tS);
        $gB = 1;
        if (!$hD->equals($this->one)) {
            goto d8C;
        }
        Ee8:
        $XN = $tS->modInverse($gu);
        $mQ[2] = $M0[2]->modInverse($M0[1]);
        return array("\x70\162\151\x76\141\164\x65\x6b\145\x79" => $this->_convertPrivateKey($ze, $tS, $XN, $M0, $ZZ, $mQ), "\160\x75\x62\x6c\151\x63\x6b\x65\x79" => $this->_convertPublicKey($ze, $tS), "\x70\141\x72\164\x69\141\x6c\153\x65\x79" => false);
    }
    function _convertPrivateKey($ze, $tS, $XN, $M0, $ZZ, $mQ)
    {
        $yq = $this->privateKeyFormat != CRYPT_RSA_PRIVATE_FORMAT_XML;
        $DX = count($M0);
        $EJ = array("\x76\145\x72\163\x69\157\156" => $DX == 2 ? chr(0) : chr(1), "\x6d\157\144\165\154\165\163" => $ze->toBytes($yq), "\x70\x75\x62\154\151\x63\105\170\160\x6f\156\x65\156\164" => $tS->toBytes($yq), "\x70\162\151\166\x61\x74\x65\105\170\x70\x6f\x6e\145\156\164" => $XN->toBytes($yq), "\160\x72\151\155\x65\61" => $M0[1]->toBytes($yq), "\x70\x72\151\x6d\x65\62" => $M0[2]->toBytes($yq), "\145\170\x70\x6f\156\145\x6e\164\61" => $ZZ[1]->toBytes($yq), "\145\170\x70\x6f\x6e\x65\156\164\x32" => $ZZ[2]->toBytes($yq), "\x63\157\x65\146\146\151\143\151\x65\156\x74" => $mQ[2]->toBytes($yq));
        switch ($this->privateKeyFormat) {
            case CRYPT_RSA_PRIVATE_FORMAT_XML:
                if (!($DX != 2)) {
                    goto ipI;
                }
                return false;
                ipI:
                return "\x3c\x52\123\x41\113\145\171\x56\x61\x6c\165\x65\x3e\15\12" . "\x20\40\x3c\115\x6f\x64\165\x6c\x75\163\x3e" . base64_encode($EJ["\x6d\157\x64\165\154\165\x73"]) . "\x3c\x2f\x4d\x6f\144\x75\154\x75\x73\76\xd\12" . "\40\40\74\105\x78\x70\157\156\x65\x6e\x74\x3e" . base64_encode($EJ["\x70\165\142\154\151\143\105\x78\x70\157\156\145\x6e\x74"]) . "\74\x2f\x45\170\160\157\x6e\x65\x6e\x74\76\xd\12" . "\40\40\x3c\x50\x3e" . base64_encode($EJ["\x70\x72\151\x6d\x65\61"]) . "\x3c\57\120\x3e\15\xa" . "\40\x20\74\x51\x3e" . base64_encode($EJ["\160\x72\x69\155\x65\62"]) . "\x3c\57\x51\x3e\xd\xa" . "\40\x20\74\104\120\x3e" . base64_encode($EJ["\145\170\160\x6f\156\x65\156\164\61"]) . "\74\x2f\104\120\x3e\xd\xa" . "\40\40\x3c\x44\x51\76" . base64_encode($EJ["\x65\170\x70\x6f\156\x65\x6e\164\62"]) . "\x3c\x2f\104\x51\76\xd\12" . "\x20\40\74\x49\156\x76\145\x72\x73\145\x51\76" . base64_encode($EJ["\x63\157\x65\146\x66\151\x63\151\145\x6e\x74"]) . "\74\57\x49\x6e\166\x65\x72\163\145\x51\x3e\xd\xa" . "\x20\40\74\x44\76" . base64_encode($EJ["\160\x72\151\166\x61\164\x65\x45\170\x70\x6f\156\145\156\164"]) . "\74\x2f\104\76\15\xa" . "\74\x2f\122\123\x41\x4b\x65\171\x56\x61\x6c\165\145\76";
                goto tuV;
            case CRYPT_RSA_PRIVATE_FORMAT_PUTTY:
                if (!($DX != 2)) {
                    goto C3P;
                }
                return false;
                C3P:
                $NZ = "\120\x75\x54\x54\x59\x2d\x55\163\145\162\x2d\113\145\x79\x2d\x46\x69\154\145\x2d\x32\72\x20\x73\163\150\55\162\x73\x61\xd\xa\105\156\143\x72\171\160\164\x69\157\x6e\x3a\40";
                $br = !empty($this->password) || is_string($this->password) ? "\x61\145\163\62\x35\x36\x2d\143\x62\143" : "\x6e\x6f\x6e\145";
                $NZ .= $br;
                $NZ .= "\15\xa\103\x6f\x6d\155\x65\156\x74\x3a\40" . $this->comment . "\15\xa";
                $xS = pack("\116\x61\x2a\x4e\141\52\116\x61\x2a", strlen("\163\x73\x68\x2d\x72\163\x61"), "\x73\163\x68\x2d\162\x73\x61", strlen($EJ["\160\x75\x62\154\x69\x63\105\170\x70\157\x6e\145\x6e\x74"]), $EJ["\160\x75\x62\154\151\143\105\170\160\157\x6e\145\x6e\x74"], strlen($EJ["\x6d\157\144\x75\154\x75\163"]), $EJ["\155\x6f\x64\x75\154\165\x73"]);
                $zl = pack("\x4e\141\x2a\116\141\52\116\x61\x2a\x4e\x61\52", strlen("\163\x73\x68\x2d\x72\x73\x61"), "\163\163\x68\55\162\163\141", strlen($br), $br, strlen($this->comment), $this->comment, strlen($xS), $xS);
                $xS = base64_encode($xS);
                $NZ .= "\x50\165\x62\154\151\143\55\114\151\x6e\145\x73\72\x20" . (strlen($xS) + 63 >> 6) . "\xd\12";
                $NZ .= chunk_split($xS, 64);
                $fn = pack("\116\141\52\x4e\141\52\116\141\x2a\x4e\x61\52", strlen($EJ["\160\162\151\x76\141\164\145\105\x78\x70\157\x6e\x65\x6e\164"]), $EJ["\x70\162\x69\x76\x61\x74\x65\x45\170\x70\x6f\156\x65\156\x74"], strlen($EJ["\160\x72\x69\155\145\x31"]), $EJ["\x70\x72\x69\155\x65\61"], strlen($EJ["\160\162\x69\x6d\145\62"]), $EJ["\160\x72\151\155\x65\62"], strlen($EJ["\x63\x6f\145\x66\x66\151\x63\x69\145\x6e\164"]), $EJ["\143\157\x65\146\x66\151\143\x69\145\x6e\x74"]);
                if (empty($this->password) && !is_string($this->password)) {
                    goto sdU;
                }
                $fn .= crypt_random_string(16 - (strlen($fn) & 15));
                $zl .= pack("\x4e\141\52", strlen($fn), $fn);
                if (class_exists("\x43\162\171\160\164\x5f\x41\105\123")) {
                    goto YCJ;
                }
                include_once "\x43\x72\x79\x70\164\x2f\101\x45\x53\x2e\160\150\160";
                YCJ:
                $qA = 0;
                $NR = '';
                Z4M:
                if (!(strlen($NR) < 32)) {
                    goto F5P;
                }
                $gu = pack("\x4e\141\52", $qA++, $this->password);
                $NR .= pack("\x48\x2a", sha1($gu));
                goto Z4M;
                F5P:
                $NR = substr($NR, 0, 32);
                $eE = new Crypt_AES();
                $eE->setKey($NR);
                $eE->disablePadding();
                $fn = $eE->encrypt($fn);
                $lc = "\160\165\x74\x74\171\x2d\160\162\151\x76\x61\164\x65\x2d\x6b\145\x79\55\146\151\154\x65\55\x6d\x61\x63\x2d\153\145\171" . $this->password;
                goto zSF;
                sdU:
                $zl .= pack("\116\141\52", strlen($fn), $fn);
                $lc = "\x70\165\x74\164\171\55\x70\162\x69\x76\141\164\145\x2d\x6b\145\x79\55\146\x69\154\145\x2d\x6d\x61\143\55\153\145\x79";
                zSF:
                $fn = base64_encode($fn);
                $NZ .= "\120\162\151\x76\141\164\145\55\x4c\151\x6e\x65\163\x3a\x20" . (strlen($fn) + 63 >> 6) . "\xd\xa";
                $NZ .= chunk_split($fn, 64);
                if (class_exists("\x43\162\x79\160\164\x5f\x48\141\163\x68")) {
                    goto NM9;
                }
                include_once "\x43\162\171\160\x74\57\110\141\x73\x68\x2e\x70\150\x70";
                NM9:
                $cA = new Crypt_Hash("\163\x68\x61\x31");
                $cA->setKey(pack("\x48\x2a", sha1($lc)));
                $NZ .= "\x50\162\151\x76\x61\x74\x65\55\x4d\x41\x43\x3a\40" . bin2hex($cA->hash($zl)) . "\15\12";
                return $NZ;
            default:
                $kK = array();
                foreach ($EJ as $O6 => $mB) {
                    $kK[$O6] = pack("\x43\x61\x2a\x61\52", CRYPT_RSA_ASN1_INTEGER, $this->_encodeLength(strlen($mB)), $mB);
                    kgD:
                }
                MAN:
                $mz = implode('', $kK);
                if (!($DX > 2)) {
                    goto K6u;
                }
                $Bb = '';
                $wz = 3;
                AVP:
                if (!($wz <= $DX)) {
                    goto hSi;
                }
                $yK = pack("\x43\141\52\x61\x2a", CRYPT_RSA_ASN1_INTEGER, $this->_encodeLength(strlen($M0[$wz]->toBytes(true))), $M0[$wz]->toBytes(true));
                $yK .= pack("\103\141\52\x61\x2a", CRYPT_RSA_ASN1_INTEGER, $this->_encodeLength(strlen($ZZ[$wz]->toBytes(true))), $ZZ[$wz]->toBytes(true));
                $yK .= pack("\103\141\52\141\52", CRYPT_RSA_ASN1_INTEGER, $this->_encodeLength(strlen($mQ[$wz]->toBytes(true))), $mQ[$wz]->toBytes(true));
                $Bb .= pack("\x43\141\52\x61\x2a", CRYPT_RSA_ASN1_SEQUENCE, $this->_encodeLength(strlen($yK)), $yK);
                HqA:
                $wz++;
                goto AVP;
                hSi:
                $mz .= pack("\x43\141\52\x61\52", CRYPT_RSA_ASN1_SEQUENCE, $this->_encodeLength(strlen($Bb)), $Bb);
                K6u:
                $mz = pack("\103\x61\52\x61\52", CRYPT_RSA_ASN1_SEQUENCE, $this->_encodeLength(strlen($mz)), $mz);
                if (!($this->privateKeyFormat == CRYPT_RSA_PRIVATE_FORMAT_PKCS8)) {
                    goto TQD;
                }
                $bJ = pack("\x48\52", "\63\60\x30\144\60\66\60\71\62\141\70\66\64\70\70\x36\x66\67\x30\x64\x30\61\60\x31\x30\x31\x30\65\60\60");
                $mz = pack("\103\x61\52\141\x2a\103\x61\52\x61\x2a", CRYPT_RSA_ASN1_INTEGER, "\1\0", $bJ, 4, $this->_encodeLength(strlen($mz)), $mz);
                $mz = pack("\103\141\x2a\x61\x2a", CRYPT_RSA_ASN1_SEQUENCE, $this->_encodeLength(strlen($mz)), $mz);
                if (!empty($this->password) || is_string($this->password)) {
                    goto fNS;
                }
                $mz = "\55\x2d\55\55\55\102\x45\x47\111\116\x20\x50\122\111\x56\101\124\105\x20\113\105\x59\x2d\55\x2d\x2d\55\xd\xa" . chunk_split(base64_encode($mz), 64) . "\55\55\55\x2d\x2d\105\116\x44\x20\x50\x52\111\126\101\124\105\x20\113\105\x59\x2d\x2d\x2d\55\55";
                goto E3T;
                fNS:
                $xW = crypt_random_string(8);
                $r3 = 2048;
                if (class_exists("\103\x72\x79\x70\x74\137\104\105\x53")) {
                    goto Wsl;
                }
                include_once "\103\162\171\160\x74\57\x44\x45\x53\x2e\160\150\160";
                Wsl:
                $eE = new Crypt_DES();
                $eE->setPassword($this->password, "\160\x62\153\144\146\x31", "\155\144\65", $xW, $r3);
                $mz = $eE->encrypt($mz);
                $vQ = pack("\103\x61\52\141\52\103\x61\52\x4e", CRYPT_RSA_ASN1_OCTETSTRING, $this->_encodeLength(strlen($xW)), $xW, CRYPT_RSA_ASN1_INTEGER, $this->_encodeLength(4), $r3);
                $YT = "\x2a\x86\x48\206\xf7\xd\1\x5\3";
                $ra = pack("\x43\x61\x2a\x61\52\x43\141\52\x61\x2a", CRYPT_RSA_ASN1_OBJECT, $this->_encodeLength(strlen($YT)), $YT, CRYPT_RSA_ASN1_SEQUENCE, $this->_encodeLength(strlen($vQ)), $vQ);
                $mz = pack("\x43\141\52\141\x2a\x43\x61\52\141\x2a", CRYPT_RSA_ASN1_SEQUENCE, $this->_encodeLength(strlen($ra)), $ra, CRYPT_RSA_ASN1_OCTETSTRING, $this->_encodeLength(strlen($mz)), $mz);
                $mz = pack("\x43\x61\52\x61\52", CRYPT_RSA_ASN1_SEQUENCE, $this->_encodeLength(strlen($mz)), $mz);
                $mz = "\55\x2d\x2d\x2d\x2d\x42\105\x47\x49\x4e\x20\105\x4e\x43\122\x59\120\124\105\104\40\x50\x52\111\126\x41\x54\x45\40\113\x45\x59\x2d\x2d\55\55\55\15\12" . chunk_split(base64_encode($mz), 64) . "\x2d\x2d\55\x2d\x2d\x45\116\104\40\105\116\103\122\x59\x50\124\105\x44\x20\x50\x52\x49\x56\x41\x54\105\40\113\x45\131\55\x2d\55\55\x2d";
                E3T:
                return $mz;
                TQD:
                if (!empty($this->password) || is_string($this->password)) {
                    goto Cx4;
                }
                $mz = "\x2d\55\x2d\55\x2d\x42\x45\x47\x49\x4e\x20\x52\x53\x41\40\120\x52\x49\x56\101\124\x45\40\113\x45\x59\55\x2d\x2d\55\x2d\xd\xa" . chunk_split(base64_encode($mz), 64) . "\55\55\55\55\55\x45\x4e\x44\x20\x52\123\x41\40\x50\122\x49\126\x41\124\105\40\x4b\x45\131\x2d\55\x2d\x2d\x2d";
                goto lnS;
                Cx4:
                $e3 = crypt_random_string(8);
                $NR = pack("\110\52", md5($this->password . $e3));
                $NR .= substr(pack("\x48\52", md5($NR . $this->password . $e3)), 0, 8);
                if (class_exists("\103\x72\x79\x70\164\137\x54\x72\151\160\154\145\104\x45\x53")) {
                    goto YV_;
                }
                include_once "\x43\x72\x79\x70\x74\x2f\124\x72\151\x70\x6c\x65\104\105\x53\56\x70\x68\160";
                YV_:
                $ob = new Crypt_TripleDES();
                $ob->setKey($NR);
                $ob->setIV($e3);
                $e3 = strtoupper(bin2hex($e3));
                $mz = "\55\x2d\55\x2d\x2d\102\x45\107\x49\116\x20\x52\123\x41\x20\120\122\111\126\x41\x54\x45\x20\x4b\105\x59\55\55\x2d\55\x2d\xd\xa" . "\x50\162\x6f\143\x2d\124\x79\x70\145\72\x20\x34\54\105\x4e\103\x52\x59\x50\124\105\x44\xd\xa" . "\x44\x45\113\55\x49\156\x66\x6f\72\x20\x44\x45\x53\x2d\x45\x44\105\x33\x2d\x43\102\103\x2c{$e3}\xd\12" . "\15\12" . chunk_split(base64_encode($ob->encrypt($mz)), 64) . "\x2d\55\55\x2d\55\x45\x4e\104\40\x52\123\x41\x20\120\122\x49\x56\x41\x54\105\40\113\105\x59\x2d\x2d\55\x2d\x2d";
                lnS:
                return $mz;
        }
        DAC:
        tuV:
    }
    function _convertPublicKey($ze, $tS)
    {
        $yq = $this->publicKeyFormat != CRYPT_RSA_PUBLIC_FORMAT_XML;
        $p5 = $ze->toBytes($yq);
        $Bj = $tS->toBytes($yq);
        switch ($this->publicKeyFormat) {
            case CRYPT_RSA_PUBLIC_FORMAT_RAW:
                return array("\x65" => $tS->copy(), "\x6e" => $ze->copy());
            case CRYPT_RSA_PUBLIC_FORMAT_XML:
                return "\74\x52\123\x41\113\x65\171\x56\141\154\x75\145\76\xd\12" . "\x20\x20\x3c\115\157\x64\165\154\x75\x73\x3e" . base64_encode($p5) . "\x3c\x2f\x4d\157\x64\x75\x6c\165\x73\x3e\xd\12" . "\x20\x20\x3c\x45\170\160\x6f\x6e\145\156\164\x3e" . base64_encode($Bj) . "\74\57\105\x78\160\157\156\145\x6e\164\76\xd\12" . "\x3c\x2f\x52\x53\x41\113\x65\171\126\x61\154\x75\x65\76";
                goto Asw;
            case CRYPT_RSA_PUBLIC_FORMAT_OPENSSH:
                $EB = pack("\116\x61\52\x4e\x61\52\x4e\x61\52", strlen("\x73\x73\150\55\162\x73\x61"), "\x73\163\150\x2d\162\x73\141", strlen($Bj), $Bj, strlen($p5), $p5);
                $EB = "\x73\x73\x68\x2d\x72\163\141\x20" . base64_encode($EB) . "\x20" . $this->comment;
                return $EB;
            default:
                $kK = array("\x6d\x6f\144\x75\154\165\x73" => pack("\x43\141\52\x61\52", CRYPT_RSA_ASN1_INTEGER, $this->_encodeLength(strlen($p5)), $p5), "\x70\165\x62\154\151\x63\x45\170\160\157\156\x65\156\x74" => pack("\103\141\x2a\x61\x2a", CRYPT_RSA_ASN1_INTEGER, $this->_encodeLength(strlen($Bj)), $Bj));
                $EB = pack("\103\141\x2a\141\52\x61\52", CRYPT_RSA_ASN1_SEQUENCE, $this->_encodeLength(strlen($kK["\x6d\x6f\144\165\154\165\x73"]) + strlen($kK["\160\165\x62\154\x69\143\x45\170\x70\157\156\x65\156\x74"])), $kK["\x6d\157\144\x75\x6c\165\x73"], $kK["\160\x75\x62\154\151\143\105\x78\x70\157\156\x65\156\164"]);
                if ($this->publicKeyFormat == CRYPT_RSA_PUBLIC_FORMAT_PKCS1_RAW) {
                    goto RNW;
                }
                $bJ = pack("\x48\x2a", "\63\x30\60\144\x30\x36\x30\71\x32\x61\70\x36\64\x38\x38\66\146\x37\x30\144\60\x31\60\x31\60\x31\60\x35\60\x30");
                $EB = chr(0) . $EB;
                $EB = chr(3) . $this->_encodeLength(strlen($EB)) . $EB;
                $EB = pack("\103\141\52\141\52", CRYPT_RSA_ASN1_SEQUENCE, $this->_encodeLength(strlen($bJ . $EB)), $bJ . $EB);
                $EB = "\55\55\x2d\x2d\x2d\102\105\107\111\x4e\40\x50\x55\x42\114\111\x43\x20\x4b\x45\131\55\55\x2d\x2d\x2d\15\12" . chunk_split(base64_encode($EB), 64) . "\x2d\55\x2d\x2d\x2d\105\116\x44\40\120\125\102\114\111\103\x20\113\105\x59\x2d\x2d\55\55\55";
                goto qKm;
                RNW:
                $EB = "\x2d\55\x2d\55\55\102\x45\107\x49\x4e\x20\x52\123\x41\x20\x50\x55\102\114\x49\103\40\x4b\105\131\x2d\x2d\55\x2d\55\xd\12" . chunk_split(base64_encode($EB), 64) . "\x2d\x2d\x2d\x2d\55\105\116\104\x20\x52\x53\x41\40\x50\x55\x42\x4c\111\103\40\x4b\x45\131\x2d\x2d\x2d\x2d\x2d";
                qKm:
                return $EB;
        }
        r9c:
        Asw:
    }
    function _parseKey($NZ, $N4)
    {
        if (!($N4 != CRYPT_RSA_PUBLIC_FORMAT_RAW && !is_string($NZ))) {
            goto FLZ;
        }
        return false;
        FLZ:
        switch ($N4) {
            case CRYPT_RSA_PUBLIC_FORMAT_RAW:
                if (is_array($NZ)) {
                    goto kFz;
                }
                return false;
                kFz:
                $kK = array();
                switch (true) {
                    case isset($NZ["\x65"]):
                        $kK["\x70\x75\142\x6c\x69\x63\x45\170\160\x6f\156\145\156\164"] = $NZ["\145"]->copy();
                        goto Y2p;
                    case isset($NZ["\x65\170\x70\157\156\145\x6e\x74"]):
                        $kK["\160\x75\x62\154\151\143\105\x78\x70\157\156\145\156\164"] = $NZ["\145\170\160\157\x6e\145\156\x74"]->copy();
                        goto Y2p;
                    case isset($NZ["\x70\x75\x62\154\151\143\x45\x78\160\157\156\145\156\164"]):
                        $kK["\x70\165\x62\154\x69\143\x45\170\160\157\x6e\145\156\x74"] = $NZ["\160\165\142\154\x69\x63\x45\x78\x70\x6f\x6e\x65\156\164"]->copy();
                        goto Y2p;
                    case isset($NZ[0]):
                        $kK["\160\x75\x62\154\151\x63\105\x78\160\157\156\x65\156\164"] = $NZ[0]->copy();
                }
                kFA:
                Y2p:
                switch (true) {
                    case isset($NZ["\x6e"]):
                        $kK["\x6d\x6f\144\x75\x6c\x75\163"] = $NZ["\156"]->copy();
                        goto gqC;
                    case isset($NZ["\155\157\x64\x75\x6c\x6f"]):
                        $kK["\x6d\157\x64\x75\154\165\163"] = $NZ["\x6d\x6f\x64\x75\x6c\x6f"]->copy();
                        goto gqC;
                    case isset($NZ["\155\x6f\x64\x75\x6c\x75\x73"]):
                        $kK["\155\x6f\x64\x75\154\x75\163"] = $NZ["\155\157\x64\x75\154\x75\163"]->copy();
                        goto gqC;
                    case isset($NZ[1]):
                        $kK["\155\157\144\x75\x6c\x75\163"] = $NZ[1]->copy();
                }
                MCa:
                gqC:
                return isset($kK["\155\x6f\144\165\x6c\x75\x73"]) && isset($kK["\x70\165\x62\154\x69\143\x45\170\160\157\x6e\x65\x6e\164"]) ? $kK : false;
            case CRYPT_RSA_PRIVATE_FORMAT_PKCS1:
            case CRYPT_RSA_PRIVATE_FORMAT_PKCS8:
            case CRYPT_RSA_PUBLIC_FORMAT_PKCS1:
                if (preg_match("\43\x44\105\x4b\x2d\111\156\x66\x6f\72\40\x28\56\53\51\54\50\56\53\51\x23", $NZ, $EZ)) {
                    goto vM2;
                }
                $qZ = $this->_extractBER($NZ);
                goto VBB;
                vM2:
                $e3 = pack("\x48\x2a", trim($EZ[2]));
                $NR = pack("\x48\x2a", md5($this->password . substr($e3, 0, 8)));
                $NR .= pack("\x48\x2a", md5($NR . $this->password . substr($e3, 0, 8)));
                $NZ = preg_replace("\x23\136\x28\x3f\x3a\120\x72\157\143\55\x54\171\160\x65\x7c\x44\105\x4b\55\111\x6e\x66\157\51\x3a\x20\x2e\x2a\x23\155", '', $NZ);
                $Rl = $this->_extractBER($NZ);
                if (!($Rl === false)) {
                    goto Cj_;
                }
                $Rl = $NZ;
                Cj_:
                switch ($EZ[1]) {
                    case "\x41\x45\x53\x2d\x32\x35\66\x2d\103\102\x43":
                        if (class_exists("\x43\162\x79\160\x74\137\x41\105\123")) {
                            goto x10;
                        }
                        include_once "\x43\162\x79\x70\x74\x2f\x41\105\123\x2e\x70\x68\160";
                        x10:
                        $eE = new Crypt_AES();
                        goto PAH;
                    case "\x41\x45\123\55\61\62\x38\x2d\x43\102\103":
                        if (class_exists("\103\x72\171\160\x74\x5f\x41\x45\x53")) {
                            goto irz;
                        }
                        include_once "\103\x72\171\160\x74\57\101\x45\123\56\160\x68\160";
                        irz:
                        $NR = substr($NR, 0, 16);
                        $eE = new Crypt_AES();
                        goto PAH;
                    case "\x44\x45\x53\55\x45\104\x45\63\55\103\x46\102":
                        if (class_exists("\103\x72\x79\x70\164\x5f\124\162\x69\160\154\145\104\105\123")) {
                            goto a5Z;
                        }
                        include_once "\x43\162\x79\x70\164\57\124\162\x69\x70\154\x65\104\105\123\x2e\x70\x68\160";
                        a5Z:
                        $eE = new Crypt_TripleDES(CRYPT_DES_MODE_CFB);
                        goto PAH;
                    case "\104\x45\x53\x2d\x45\x44\x45\x33\55\x43\102\x43":
                        if (class_exists("\x43\x72\171\x70\x74\x5f\x54\x72\x69\x70\x6c\145\x44\105\x53")) {
                            goto ufg;
                        }
                        include_once "\103\x72\171\x70\x74\57\124\162\x69\160\x6c\x65\104\x45\x53\56\160\x68\x70";
                        ufg:
                        $NR = substr($NR, 0, 24);
                        $eE = new Crypt_TripleDES();
                        goto PAH;
                    case "\x44\105\123\x2d\103\102\x43":
                        if (class_exists("\103\162\171\160\x74\137\104\x45\123")) {
                            goto GO9;
                        }
                        include_once "\x43\162\x79\x70\x74\57\x44\x45\x53\56\x70\x68\160";
                        GO9:
                        $eE = new Crypt_DES();
                        goto PAH;
                    default:
                        return false;
                }
                ev1:
                PAH:
                $eE->setKey($NR);
                $eE->setIV($e3);
                $qZ = $eE->decrypt($Rl);
                VBB:
                if (!($qZ !== false)) {
                    goto tCR;
                }
                $NZ = $qZ;
                tCR:
                $kK = array();
                if (!(ord($this->_string_shift($NZ)) != CRYPT_RSA_ASN1_SEQUENCE)) {
                    goto DQ_;
                }
                return false;
                DQ_:
                if (!($this->_decodeLength($NZ) != strlen($NZ))) {
                    goto A25;
                }
                return false;
                A25:
                $XL = ord($this->_string_shift($NZ));
                if (!($XL == CRYPT_RSA_ASN1_INTEGER && substr($NZ, 0, 3) == "\1\x0\x30")) {
                    goto DMC;
                }
                $this->_string_shift($NZ, 3);
                $XL = CRYPT_RSA_ASN1_SEQUENCE;
                DMC:
                if (!($XL == CRYPT_RSA_ASN1_SEQUENCE)) {
                    goto Lom;
                }
                $gu = $this->_string_shift($NZ, $this->_decodeLength($NZ));
                if (!(ord($this->_string_shift($gu)) != CRYPT_RSA_ASN1_OBJECT)) {
                    goto sxm;
                }
                return false;
                sxm:
                $ql = $this->_decodeLength($gu);
                switch ($this->_string_shift($gu, $ql)) {
                    case "\x2a\x86\110\206\xf7\xd\1\x1\1":
                        goto D8u;
                    case "\x2a\206\x48\x86\367\xd\x1\5\3":
                        if (!(ord($this->_string_shift($gu)) != CRYPT_RSA_ASN1_SEQUENCE)) {
                            goto DxI;
                        }
                        return false;
                        DxI:
                        if (!($this->_decodeLength($gu) != strlen($gu))) {
                            goto nGG;
                        }
                        return false;
                        nGG:
                        $this->_string_shift($gu);
                        $xW = $this->_string_shift($gu, $this->_decodeLength($gu));
                        if (!(ord($this->_string_shift($gu)) != CRYPT_RSA_ASN1_INTEGER)) {
                            goto m3I;
                        }
                        return false;
                        m3I:
                        $this->_decodeLength($gu);
                        list(, $r3) = unpack("\116", str_pad($gu, 4, chr(0), STR_PAD_LEFT));
                        $this->_string_shift($NZ);
                        $ql = $this->_decodeLength($NZ);
                        if (!(strlen($NZ) != $ql)) {
                            goto JBJ;
                        }
                        return false;
                        JBJ:
                        if (class_exists("\x43\x72\171\160\x74\137\104\105\x53")) {
                            goto Zjj;
                        }
                        include_once "\103\162\x79\160\164\x2f\104\105\123\x2e\x70\150\160";
                        Zjj:
                        $eE = new Crypt_DES();
                        $eE->setPassword($this->password, "\x70\x62\153\x64\x66\61", "\155\x64\65", $xW, $r3);
                        $NZ = $eE->decrypt($NZ);
                        if (!($NZ === false)) {
                            goto Ts6;
                        }
                        return false;
                        Ts6:
                        return $this->_parseKey($NZ, CRYPT_RSA_PRIVATE_FORMAT_PKCS1);
                    default:
                        return false;
                }
                CZ0:
                D8u:
                $XL = ord($this->_string_shift($NZ));
                $this->_decodeLength($NZ);
                if (!($XL == CRYPT_RSA_ASN1_BITSTRING)) {
                    goto MqP;
                }
                $this->_string_shift($NZ);
                MqP:
                if (!(ord($this->_string_shift($NZ)) != CRYPT_RSA_ASN1_SEQUENCE)) {
                    goto Clb;
                }
                return false;
                Clb:
                if (!($this->_decodeLength($NZ) != strlen($NZ))) {
                    goto qhn;
                }
                return false;
                qhn:
                $XL = ord($this->_string_shift($NZ));
                Lom:
                if (!($XL != CRYPT_RSA_ASN1_INTEGER)) {
                    goto Q0x;
                }
                return false;
                Q0x:
                $ql = $this->_decodeLength($NZ);
                $gu = $this->_string_shift($NZ, $ql);
                if (!(strlen($gu) != 1 || ord($gu) > 2)) {
                    goto J_s;
                }
                $kK["\x6d\x6f\144\x75\154\x75\x73"] = new Math_BigInteger($gu, 256);
                $this->_string_shift($NZ);
                $ql = $this->_decodeLength($NZ);
                $kK[$N4 == CRYPT_RSA_PUBLIC_FORMAT_PKCS1 ? "\x70\165\142\154\151\x63\105\x78\160\x6f\156\145\156\x74" : "\160\x72\151\166\x61\x74\145\x45\170\x70\x6f\x6e\x65\x6e\x74"] = new Math_BigInteger($this->_string_shift($NZ, $ql), 256);
                return $kK;
                J_s:
                if (!(ord($this->_string_shift($NZ)) != CRYPT_RSA_ASN1_INTEGER)) {
                    goto ppt;
                }
                return false;
                ppt:
                $ql = $this->_decodeLength($NZ);
                $kK["\155\x6f\x64\x75\x6c\165\x73"] = new Math_BigInteger($this->_string_shift($NZ, $ql), 256);
                $this->_string_shift($NZ);
                $ql = $this->_decodeLength($NZ);
                $kK["\x70\x75\x62\154\x69\x63\x45\170\x70\157\x6e\x65\156\x74"] = new Math_BigInteger($this->_string_shift($NZ, $ql), 256);
                $this->_string_shift($NZ);
                $ql = $this->_decodeLength($NZ);
                $kK["\160\162\151\x76\141\x74\x65\105\170\160\x6f\156\x65\156\164"] = new Math_BigInteger($this->_string_shift($NZ, $ql), 256);
                $this->_string_shift($NZ);
                $ql = $this->_decodeLength($NZ);
                $kK["\160\x72\x69\155\145\163"] = array(1 => new Math_BigInteger($this->_string_shift($NZ, $ql), 256));
                $this->_string_shift($NZ);
                $ql = $this->_decodeLength($NZ);
                $kK["\x70\x72\x69\x6d\x65\x73"][] = new Math_BigInteger($this->_string_shift($NZ, $ql), 256);
                $this->_string_shift($NZ);
                $ql = $this->_decodeLength($NZ);
                $kK["\145\x78\x70\x6f\x6e\145\x6e\164\x73"] = array(1 => new Math_BigInteger($this->_string_shift($NZ, $ql), 256));
                $this->_string_shift($NZ);
                $ql = $this->_decodeLength($NZ);
                $kK["\145\x78\x70\157\x6e\x65\x6e\x74\x73"][] = new Math_BigInteger($this->_string_shift($NZ, $ql), 256);
                $this->_string_shift($NZ);
                $ql = $this->_decodeLength($NZ);
                $kK["\x63\157\145\x66\x66\151\143\151\x65\156\164\163"] = array(2 => new Math_BigInteger($this->_string_shift($NZ, $ql), 256));
                if (empty($NZ)) {
                    goto Jrm;
                }
                if (!(ord($this->_string_shift($NZ)) != CRYPT_RSA_ASN1_SEQUENCE)) {
                    goto CRj;
                }
                return false;
                CRj:
                $this->_decodeLength($NZ);
                QwT:
                if (empty($NZ)) {
                    goto hYe;
                }
                if (!(ord($this->_string_shift($NZ)) != CRYPT_RSA_ASN1_SEQUENCE)) {
                    goto JTy;
                }
                return false;
                JTy:
                $this->_decodeLength($NZ);
                $NZ = substr($NZ, 1);
                $ql = $this->_decodeLength($NZ);
                $kK["\x70\162\151\155\145\x73"][] = new Math_BigInteger($this->_string_shift($NZ, $ql), 256);
                $this->_string_shift($NZ);
                $ql = $this->_decodeLength($NZ);
                $kK["\x65\x78\x70\157\156\x65\x6e\164\163"][] = new Math_BigInteger($this->_string_shift($NZ, $ql), 256);
                $this->_string_shift($NZ);
                $ql = $this->_decodeLength($NZ);
                $kK["\143\x6f\x65\x66\x66\x69\143\x69\x65\156\x74\x73"][] = new Math_BigInteger($this->_string_shift($NZ, $ql), 256);
                goto QwT;
                hYe:
                Jrm:
                return $kK;
            case CRYPT_RSA_PUBLIC_FORMAT_OPENSSH:
                $Rs = explode("\40", $NZ, 3);
                $NZ = isset($Rs[1]) ? base64_decode($Rs[1]) : false;
                if (!($NZ === false)) {
                    goto sTV;
                }
                return false;
                sTV:
                $hl = isset($Rs[2]) ? $Rs[2] : false;
                $tO = substr($NZ, 0, 11) == "\0\0\0\x7\x73\163\150\x2d\x72\163\141";
                if (!(strlen($NZ) <= 4)) {
                    goto L26;
                }
                return false;
                L26:
                extract(unpack("\116\x6c\145\156\x67\x74\x68", $this->_string_shift($NZ, 4)));
                $Bj = new Math_BigInteger($this->_string_shift($NZ, $ql), -256);
                if (!(strlen($NZ) <= 4)) {
                    goto QbN;
                }
                return false;
                QbN:
                extract(unpack("\x4e\x6c\x65\156\147\x74\x68", $this->_string_shift($NZ, 4)));
                $p5 = new Math_BigInteger($this->_string_shift($NZ, $ql), -256);
                if ($tO && strlen($NZ)) {
                    goto hjt;
                }
                return strlen($NZ) ? false : array("\x6d\x6f\x64\x75\x6c\x75\x73" => $p5, "\160\x75\x62\154\x69\143\x45\170\x70\x6f\x6e\x65\x6e\x74" => $Bj, "\143\x6f\155\155\145\x6e\164" => $hl);
                goto PAs;
                hjt:
                if (!(strlen($NZ) <= 4)) {
                    goto SGG;
                }
                return false;
                SGG:
                extract(unpack("\116\154\x65\x6e\x67\164\x68", $this->_string_shift($NZ, 4)));
                $Ke = new Math_BigInteger($this->_string_shift($NZ, $ql), -256);
                return strlen($NZ) ? false : array("\x6d\x6f\x64\x75\154\x75\163" => $Ke, "\160\x75\142\x6c\x69\143\105\170\x70\157\x6e\145\156\x74" => $p5, "\x63\157\155\155\145\156\x74" => $hl);
                PAs:
            case CRYPT_RSA_PRIVATE_FORMAT_XML:
            case CRYPT_RSA_PUBLIC_FORMAT_XML:
                $this->components = array();
                $Sg = xml_parser_create("\x55\124\x46\55\x38");
                xml_set_object($Sg, $this);
                xml_set_element_handler($Sg, "\137\163\164\141\162\164\x5f\x65\154\x65\x6d\x65\156\164\137\150\x61\x6e\144\154\x65\x72", "\137\163\164\x6f\160\x5f\145\154\x65\x6d\x65\156\164\137\150\141\x6e\x64\x6c\145\x72");
                xml_set_character_data_handler($Sg, "\x5f\144\x61\x74\141\x5f\x68\141\156\x64\154\145\162");
                if (xml_parse($Sg, "\74\170\x6d\x6c\76" . $NZ . "\74\x2f\170\x6d\154\76")) {
                    goto bzA;
                }
                return false;
                bzA:
                return isset($this->components["\x6d\157\x64\x75\154\165\163"]) && isset($this->components["\x70\165\142\x6c\151\x63\x45\x78\160\157\x6e\x65\x6e\x74"]) ? $this->components : false;
            case CRYPT_RSA_PRIVATE_FORMAT_PUTTY:
                $kK = array();
                $NZ = preg_split("\x23\134\162\134\x6e\x7c\134\162\174\x5c\x6e\x23", $NZ);
                $N4 = trim(preg_replace("\x23\x50\165\124\x54\x59\55\125\163\145\162\55\x4b\145\171\x2d\x46\x69\x6c\145\55\x32\72\40\x28\56\x2b\x29\43", "\x24\61", $NZ[0]));
                if (!($N4 != "\x73\x73\150\x2d\x72\x73\141")) {
                    goto BC1;
                }
                return false;
                BC1:
                $br = trim(preg_replace("\x23\x45\x6e\143\x72\x79\160\164\151\x6f\156\x3a\40\x28\x2e\53\51\43", "\x24\x31", $NZ[1]));
                $hl = trim(preg_replace("\x23\103\157\155\x6d\145\156\164\72\40\50\56\x2b\x29\43", "\44\x31", $NZ[2]));
                $N9 = trim(preg_replace("\43\120\165\142\154\151\x63\x2d\114\151\156\x65\163\72\40\x28\134\144\x2b\x29\x23", "\x24\61", $NZ[3]));
                $xS = base64_decode(implode('', array_map("\x74\x72\x69\155", array_slice($NZ, 4, $N9))));
                $xS = substr($xS, 11);
                extract(unpack("\x4e\x6c\x65\156\147\x74\150", $this->_string_shift($xS, 4)));
                $kK["\160\165\142\x6c\151\x63\x45\x78\160\x6f\156\x65\x6e\164"] = new Math_BigInteger($this->_string_shift($xS, $ql), -256);
                extract(unpack("\x4e\x6c\145\x6e\147\x74\x68", $this->_string_shift($xS, 4)));
                $kK["\x6d\157\x64\165\x6c\x75\163"] = new Math_BigInteger($this->_string_shift($xS, $ql), -256);
                $Re = trim(preg_replace("\43\120\162\x69\x76\x61\x74\x65\x2d\x4c\151\x6e\145\x73\72\x20\x28\134\x64\53\x29\43", "\x24\x31", $NZ[$N9 + 4]));
                $fn = base64_decode(implode('', array_map("\164\x72\x69\155", array_slice($NZ, $N9 + 5, $Re))));
                switch ($br) {
                    case "\x61\145\163\x32\x35\x36\x2d\143\x62\x63":
                        if (class_exists("\x43\162\x79\x70\164\137\x41\105\123")) {
                            goto wk8;
                        }
                        include_once "\x43\162\171\x70\164\57\x41\x45\123\x2e\x70\150\160";
                        wk8:
                        $NR = '';
                        $qA = 0;
                        geI:
                        if (!(strlen($NR) < 32)) {
                            goto Yn3;
                        }
                        $gu = pack("\116\141\x2a", $qA++, $this->password);
                        $NR .= pack("\x48\x2a", sha1($gu));
                        goto geI;
                        Yn3:
                        $NR = substr($NR, 0, 32);
                        $eE = new Crypt_AES();
                }
                GO6:
                to6:
                if (!($br != "\x6e\157\156\145")) {
                    goto nCo;
                }
                $eE->setKey($NR);
                $eE->disablePadding();
                $fn = $eE->decrypt($fn);
                if (!($fn === false)) {
                    goto LPX;
                }
                return false;
                LPX:
                nCo:
                extract(unpack("\116\x6c\x65\156\x67\164\x68", $this->_string_shift($fn, 4)));
                if (!(strlen($fn) < $ql)) {
                    goto uWM;
                }
                return false;
                uWM:
                $kK["\x70\x72\x69\166\x61\164\145\x45\170\160\157\x6e\145\156\x74"] = new Math_BigInteger($this->_string_shift($fn, $ql), -256);
                extract(unpack("\116\x6c\145\156\147\164\150", $this->_string_shift($fn, 4)));
                if (!(strlen($fn) < $ql)) {
                    goto auJ;
                }
                return false;
                auJ:
                $kK["\160\x72\151\155\x65\x73"] = array(1 => new Math_BigInteger($this->_string_shift($fn, $ql), -256));
                extract(unpack("\x4e\154\x65\x6e\147\164\150", $this->_string_shift($fn, 4)));
                if (!(strlen($fn) < $ql)) {
                    goto BLt;
                }
                return false;
                BLt:
                $kK["\160\162\x69\x6d\145\x73"][] = new Math_BigInteger($this->_string_shift($fn, $ql), -256);
                $gu = $kK["\160\x72\151\155\145\163"][1]->subtract($this->one);
                $kK["\145\170\160\157\x6e\145\x6e\x74\163"] = array(1 => $kK["\160\165\x62\154\x69\x63\x45\x78\x70\157\x6e\145\x6e\164"]->modInverse($gu));
                $gu = $kK["\x70\162\x69\x6d\145\163"][2]->subtract($this->one);
                $kK["\x65\170\x70\157\x6e\x65\156\x74\163"][] = $kK["\160\165\x62\154\151\143\105\170\160\x6f\156\145\156\x74"]->modInverse($gu);
                extract(unpack("\116\x6c\x65\156\147\x74\150", $this->_string_shift($fn, 4)));
                if (!(strlen($fn) < $ql)) {
                    goto eLM;
                }
                return false;
                eLM:
                $kK["\143\157\x65\146\x66\x69\143\151\x65\156\164\x73"] = array(2 => new Math_BigInteger($this->_string_shift($fn, $ql), -256));
                return $kK;
        }
        B7q:
        BQv:
    }
    function getSize()
    {
        return !isset($this->modulus) ? 0 : strlen($this->modulus->toBits());
    }
    function _start_element_handler($Br, $O6, $aO)
    {
        switch ($O6) {
            case "\x4d\x4f\x44\x55\114\125\x53":
                $this->current =& $this->components["\155\x6f\x64\x75\x6c\165\163"];
                goto QcA;
            case "\x45\130\120\117\x4e\105\x4e\x54":
                $this->current =& $this->components["\x70\165\142\154\x69\x63\105\x78\160\157\x6e\x65\x6e\x74"];
                goto QcA;
            case "\x50":
                $this->current =& $this->components["\160\162\151\x6d\145\163"][1];
                goto QcA;
            case "\x51":
                $this->current =& $this->components["\160\x72\x69\x6d\145\x73"][2];
                goto QcA;
            case "\104\120":
                $this->current =& $this->components["\x65\170\x70\x6f\156\x65\x6e\x74\163"][1];
                goto QcA;
            case "\104\121":
                $this->current =& $this->components["\x65\170\160\157\156\145\x6e\164\x73"][2];
                goto QcA;
            case "\x49\x4e\126\x45\122\123\105\x51":
                $this->current =& $this->components["\143\157\145\146\146\151\x63\x69\x65\156\x74\163"][2];
                goto QcA;
            case "\x44":
                $this->current =& $this->components["\160\x72\151\x76\141\164\x65\x45\x78\x70\x6f\x6e\x65\x6e\164"];
        }
        nmw:
        QcA:
        $this->current = '';
    }
    function _stop_element_handler($Br, $O6)
    {
        if (!isset($this->current)) {
            goto Ag7;
        }
        $this->current = new Math_BigInteger(base64_decode($this->current), 256);
        unset($this->current);
        Ag7:
    }
    function _data_handler($Br, $s8)
    {
        if (!(!isset($this->current) || is_object($this->current))) {
            goto CUn;
        }
        return;
        CUn:
        $this->current .= trim($s8);
    }
    function loadKey($NZ, $N4 = false)
    {
        if (!(is_object($NZ) && strtolower(get_class($NZ)) == "\143\162\x79\x70\x74\x5f\162\x73\x61")) {
            goto Boi;
        }
        $this->privateKeyFormat = $NZ->privateKeyFormat;
        $this->publicKeyFormat = $NZ->publicKeyFormat;
        $this->k = $NZ->k;
        $this->hLen = $NZ->hLen;
        $this->sLen = $NZ->sLen;
        $this->mgfHLen = $NZ->mgfHLen;
        $this->encryptionMode = $NZ->encryptionMode;
        $this->signatureMode = $NZ->signatureMode;
        $this->password = $NZ->password;
        $this->configFile = $NZ->configFile;
        $this->comment = $NZ->comment;
        if (!is_object($NZ->hash)) {
            goto yZM;
        }
        $this->hash = new Crypt_Hash($NZ->hash->getHash());
        yZM:
        if (!is_object($NZ->mgfHash)) {
            goto crj;
        }
        $this->mgfHash = new Crypt_Hash($NZ->mgfHash->getHash());
        crj:
        if (!is_object($NZ->modulus)) {
            goto X5F;
        }
        $this->modulus = $NZ->modulus->copy();
        X5F:
        if (!is_object($NZ->exponent)) {
            goto h9a;
        }
        $this->exponent = $NZ->exponent->copy();
        h9a:
        if (!is_object($NZ->publicExponent)) {
            goto LwF;
        }
        $this->publicExponent = $NZ->publicExponent->copy();
        LwF:
        $this->primes = array();
        $this->exponents = array();
        $this->coefficients = array();
        foreach ($this->primes as $Fb) {
            $this->primes[] = $Fb->copy();
            YC0:
        }
        mXe:
        foreach ($this->exponents as $f6) {
            $this->exponents[] = $f6->copy();
            lXE:
        }
        JD7:
        foreach ($this->coefficients as $wS) {
            $this->coefficients[] = $wS->copy();
            T_0:
        }
        vwU:
        return true;
        Boi:
        if ($N4 === false) {
            goto CvS;
        }
        $kK = $this->_parseKey($NZ, $N4);
        goto av2;
        CvS:
        $g7 = array(CRYPT_RSA_PUBLIC_FORMAT_RAW, CRYPT_RSA_PRIVATE_FORMAT_PKCS1, CRYPT_RSA_PRIVATE_FORMAT_XML, CRYPT_RSA_PRIVATE_FORMAT_PUTTY, CRYPT_RSA_PUBLIC_FORMAT_OPENSSH);
        foreach ($g7 as $N4) {
            $kK = $this->_parseKey($NZ, $N4);
            if (!($kK !== false)) {
                goto AG6;
            }
            goto AzV;
            AG6:
            RRI:
        }
        AzV:
        av2:
        if (!($kK === false)) {
            goto qNz;
        }
        $this->comment = null;
        $this->modulus = null;
        $this->k = null;
        $this->exponent = null;
        $this->primes = null;
        $this->exponents = null;
        $this->coefficients = null;
        $this->publicExponent = null;
        return false;
        qNz:
        if (!(isset($kK["\x63\x6f\155\155\145\156\164"]) && $kK["\143\157\x6d\155\145\156\164"] !== false)) {
            goto SGR;
        }
        $this->comment = $kK["\143\157\x6d\x6d\145\x6e\x74"];
        SGR:
        $this->modulus = $kK["\x6d\157\x64\x75\x6c\165\x73"];
        $this->k = strlen($this->modulus->toBytes());
        $this->exponent = isset($kK["\x70\162\x69\166\x61\x74\x65\105\170\x70\x6f\x6e\145\156\164"]) ? $kK["\160\x72\x69\166\x61\x74\145\x45\x78\160\x6f\156\145\156\164"] : $kK["\x70\165\x62\x6c\151\x63\x45\x78\x70\157\156\x65\x6e\164"];
        if (isset($kK["\160\x72\x69\155\x65\x73"])) {
            goto vdU;
        }
        $this->primes = array();
        $this->exponents = array();
        $this->coefficients = array();
        $this->publicExponent = false;
        goto i1v;
        vdU:
        $this->primes = $kK["\160\x72\151\x6d\145\x73"];
        $this->exponents = $kK["\145\170\x70\157\156\145\156\164\163"];
        $this->coefficients = $kK["\143\157\x65\x66\146\x69\143\151\145\156\x74\163"];
        $this->publicExponent = $kK["\x70\x75\142\x6c\x69\x63\x45\x78\x70\157\x6e\x65\156\164"];
        i1v:
        switch ($N4) {
            case CRYPT_RSA_PUBLIC_FORMAT_OPENSSH:
            case CRYPT_RSA_PUBLIC_FORMAT_RAW:
                $this->setPublicKey();
                goto zsb;
            case CRYPT_RSA_PRIVATE_FORMAT_PKCS1:
                switch (true) {
                    case strpos($NZ, "\55\x42\105\x47\111\x4e\40\x50\x55\x42\114\x49\103\40\113\x45\131\55") !== false:
                    case strpos($NZ, "\55\x42\x45\107\x49\116\40\x52\123\101\40\120\x55\x42\114\111\x43\40\x4b\x45\x59\x2d") !== false:
                        $this->setPublicKey();
                }
                feV:
                ojC:
        }
        H5Z:
        zsb:
        return true;
    }
    function setPassword($oa = false)
    {
        $this->password = $oa;
    }
    function setPublicKey($NZ = false, $N4 = false)
    {
        if (empty($this->publicExponent)) {
            goto l9W;
        }
        return false;
        l9W:
        if (!($NZ === false && !empty($this->modulus))) {
            goto ZdS;
        }
        $this->publicExponent = $this->exponent;
        return true;
        ZdS:
        if ($N4 === false) {
            goto IXY;
        }
        $kK = $this->_parseKey($NZ, $N4);
        goto zgV;
        IXY:
        $g7 = array(CRYPT_RSA_PUBLIC_FORMAT_RAW, CRYPT_RSA_PUBLIC_FORMAT_PKCS1, CRYPT_RSA_PUBLIC_FORMAT_XML, CRYPT_RSA_PUBLIC_FORMAT_OPENSSH);
        foreach ($g7 as $N4) {
            $kK = $this->_parseKey($NZ, $N4);
            if (!($kK !== false)) {
                goto fHi;
            }
            goto qIb;
            fHi:
            Lud:
        }
        qIb:
        zgV:
        if (!($kK === false)) {
            goto V7M;
        }
        return false;
        V7M:
        if (!(empty($this->modulus) || !$this->modulus->equals($kK["\155\157\x64\x75\x6c\165\x73"]))) {
            goto IFT;
        }
        $this->modulus = $kK["\x6d\157\144\165\x6c\x75\x73"];
        $this->exponent = $this->publicExponent = $kK["\x70\165\x62\x6c\151\x63\x45\170\160\x6f\x6e\145\x6e\x74"];
        return true;
        IFT:
        $this->publicExponent = $kK["\x70\165\x62\154\x69\143\x45\170\160\157\156\145\156\x74"];
        return true;
    }
    function setPrivateKey($NZ = false, $N4 = false)
    {
        if (!($NZ === false && !empty($this->publicExponent))) {
            goto xq6;
        }
        $this->publicExponent = false;
        return true;
        xq6:
        $NS = new Crypt_RSA();
        if ($NS->loadKey($NZ, $N4)) {
            goto zIm;
        }
        return false;
        zIm:
        $NS->publicExponent = false;
        $this->loadKey($NS);
        return true;
    }
    function getPublicKey($N4 = CRYPT_RSA_PUBLIC_FORMAT_PKCS8)
    {
        if (!(empty($this->modulus) || empty($this->publicExponent))) {
            goto r5W;
        }
        return false;
        r5W:
        $pj = $this->publicKeyFormat;
        $this->publicKeyFormat = $N4;
        $gu = $this->_convertPublicKey($this->modulus, $this->publicExponent);
        $this->publicKeyFormat = $pj;
        return $gu;
    }
    function getPublicKeyFingerprint($A1 = "\x6d\144\65")
    {
        if (!(empty($this->modulus) || empty($this->publicExponent))) {
            goto IVq;
        }
        return false;
        IVq:
        $p5 = $this->modulus->toBytes(true);
        $Bj = $this->publicExponent->toBytes(true);
        $EB = pack("\116\x61\x2a\x4e\x61\52\116\141\52", strlen("\x73\x73\150\x2d\x72\163\x61"), "\163\x73\150\55\162\x73\x61", strlen($Bj), $Bj, strlen($p5), $p5);
        switch ($A1) {
            case "\x73\x68\x61\62\65\x36":
                $cA = new Crypt_Hash("\163\x68\141\62\x35\66");
                $Oo = base64_encode($cA->hash($EB));
                return substr($Oo, 0, strlen($Oo) - 1);
            case "\155\144\x35":
                return substr(chunk_split(md5($EB), 2, "\x3a"), 0, -1);
            default:
                return false;
        }
        Ad2:
        L10:
    }
    function getPrivateKey($N4 = CRYPT_RSA_PUBLIC_FORMAT_PKCS1)
    {
        if (!empty($this->primes)) {
            goto NR_;
        }
        return false;
        NR_:
        $pj = $this->privateKeyFormat;
        $this->privateKeyFormat = $N4;
        $gu = $this->_convertPrivateKey($this->modulus, $this->publicExponent, $this->exponent, $this->primes, $this->exponents, $this->coefficients);
        $this->privateKeyFormat = $pj;
        return $gu;
    }
    function _getPrivatePublicKey($qi = CRYPT_RSA_PUBLIC_FORMAT_PKCS8)
    {
        if (!(empty($this->modulus) || empty($this->exponent))) {
            goto Pw1;
        }
        return false;
        Pw1:
        $pj = $this->publicKeyFormat;
        $this->publicKeyFormat = $qi;
        $gu = $this->_convertPublicKey($this->modulus, $this->exponent);
        $this->publicKeyFormat = $pj;
        return $gu;
    }
    function __toString()
    {
        $NZ = $this->getPrivateKey($this->privateKeyFormat);
        if (!($NZ !== false)) {
            goto vSj;
        }
        return $NZ;
        vSj:
        $NZ = $this->_getPrivatePublicKey($this->publicKeyFormat);
        return $NZ !== false ? $NZ : '';
    }
    function __clone()
    {
        $NZ = new Crypt_RSA();
        $NZ->loadKey($this);
        return $NZ;
    }
    function _generateMinMax($fZ)
    {
        $DJ = $fZ >> 3;
        $FT = str_repeat(chr(0), $DJ);
        $KF = str_repeat(chr(0xff), $DJ);
        $Zj = $fZ & 7;
        if ($Zj) {
            goto ITB;
        }
        $FT[0] = chr(0x80);
        goto iEr;
        ITB:
        $FT = chr(1 << $Zj - 1) . $FT;
        $KF = chr((1 << $Zj) - 1) . $KF;
        iEr:
        return array("\x6d\151\156" => new Math_BigInteger($FT, 256), "\155\x61\170" => new Math_BigInteger($KF, 256));
    }
    function _decodeLength(&$JK)
    {
        $ql = ord($this->_string_shift($JK));
        if (!($ql & 0x80)) {
            goto dw6;
        }
        $ql &= 0x7f;
        $gu = $this->_string_shift($JK, $ql);
        list(, $ql) = unpack("\116", substr(str_pad($gu, 4, chr(0), STR_PAD_LEFT), -4));
        dw6:
        return $ql;
    }
    function _encodeLength($ql)
    {
        if (!($ql <= 0x7f)) {
            goto QTZ;
        }
        return chr($ql);
        QTZ:
        $gu = ltrim(pack("\x4e", $ql), chr(0));
        return pack("\103\x61\52", 0x80 | strlen($gu), $gu);
    }
    function _string_shift(&$JK, $bu = 1)
    {
        $KZ = substr($JK, 0, $bu);
        $JK = substr($JK, $bu);
        return $KZ;
    }
    function setPrivateKeyFormat($ss)
    {
        $this->privateKeyFormat = $ss;
    }
    function setPublicKeyFormat($ss)
    {
        $this->publicKeyFormat = $ss;
    }
    function setHash($cA)
    {
        switch ($cA) {
            case "\155\x64\62":
            case "\x6d\x64\65":
            case "\163\150\x61\61":
            case "\163\x68\141\x32\x35\66":
            case "\x73\150\141\63\x38\64":
            case "\163\x68\x61\x35\61\62":
                $this->hash = new Crypt_Hash($cA);
                $this->hashName = $cA;
                goto iBx;
            default:
                $this->hash = new Crypt_Hash("\163\x68\141\61");
                $this->hashName = "\x73\150\141\61";
        }
        yOS:
        iBx:
        $this->hLen = $this->hash->getLength();
    }
    function setMGFHash($cA)
    {
        switch ($cA) {
            case "\x6d\144\x32":
            case "\x6d\144\65":
            case "\163\150\x61\61":
            case "\163\x68\141\x32\x35\66":
            case "\x73\x68\x61\63\x38\64":
            case "\x73\150\x61\x35\x31\x32":
                $this->mgfHash = new Crypt_Hash($cA);
                goto f4R;
            default:
                $this->mgfHash = new Crypt_Hash("\x73\150\x61\61");
        }
        ZDd:
        f4R:
        $this->mgfHLen = $this->mgfHash->getLength();
    }
    function setSaltLength($QA)
    {
        $this->sLen = $QA;
    }
    function _i2osp($Av, $h2)
    {
        $Av = $Av->toBytes();
        if (!(strlen($Av) > $h2)) {
            goto B7a;
        }
        user_error("\111\x6e\164\x65\x67\145\162\40\x74\157\x6f\x20\154\141\162\x67\145");
        return false;
        B7a:
        return str_pad($Av, $h2, chr(0), STR_PAD_LEFT);
    }
    function _os2ip($Av)
    {
        return new Math_BigInteger($Av, 256);
    }
    function _exponentiate($Av)
    {
        switch (true) {
            case empty($this->primes):
            case $this->primes[1]->equals($this->zero):
            case empty($this->coefficients):
            case $this->coefficients[2]->equals($this->zero):
            case empty($this->exponents):
            case $this->exponents[1]->equals($this->zero):
                return $Av->modPow($this->exponent, $this->modulus);
        }
        RqS:
        LGm:
        $DX = count($this->primes);
        if (defined("\103\x52\131\120\x54\x5f\122\123\101\137\x44\x49\x53\101\102\114\x45\137\102\x4c\111\116\104\111\x4e\x47")) {
            goto jlD;
        }
        $aM = $this->primes[1];
        $wz = 2;
        J8b:
        if (!($wz <= $DX)) {
            goto Olt;
        }
        if (!($aM->compare($this->primes[$wz]) > 0)) {
            goto JDl;
        }
        $aM = $this->primes[$wz];
        JDl:
        pv6:
        $wz++;
        goto J8b;
        Olt:
        $HN = new Math_BigInteger(1);
        $AL = $HN->random($HN, $aM->subtract($HN));
        $nC = array(1 => $this->_blind($Av, $AL, 1), 2 => $this->_blind($Av, $AL, 2));
        $ce = $nC[1]->subtract($nC[2]);
        $ce = $ce->multiply($this->coefficients[2]);
        list(, $ce) = $ce->divide($this->primes[1]);
        $x4 = $nC[2]->add($ce->multiply($this->primes[2]));
        $AL = $this->primes[1];
        $wz = 3;
        A_s:
        if (!($wz <= $DX)) {
            goto ETb;
        }
        $nC = $this->_blind($Av, $AL, $wz);
        $AL = $AL->multiply($this->primes[$wz - 1]);
        $ce = $nC->subtract($x4);
        $ce = $ce->multiply($this->coefficients[$wz]);
        list(, $ce) = $ce->divide($this->primes[$wz]);
        $x4 = $x4->add($AL->multiply($ce));
        D1C:
        $wz++;
        goto A_s;
        ETb:
        goto ead;
        jlD:
        $nC = array(1 => $Av->modPow($this->exponents[1], $this->primes[1]), 2 => $Av->modPow($this->exponents[2], $this->primes[2]));
        $ce = $nC[1]->subtract($nC[2]);
        $ce = $ce->multiply($this->coefficients[2]);
        list(, $ce) = $ce->divide($this->primes[1]);
        $x4 = $nC[2]->add($ce->multiply($this->primes[2]));
        $AL = $this->primes[1];
        $wz = 3;
        xFc:
        if (!($wz <= $DX)) {
            goto vHJ;
        }
        $nC = $Av->modPow($this->exponents[$wz], $this->primes[$wz]);
        $AL = $AL->multiply($this->primes[$wz - 1]);
        $ce = $nC->subtract($x4);
        $ce = $ce->multiply($this->coefficients[$wz]);
        list(, $ce) = $ce->divide($this->primes[$wz]);
        $x4 = $x4->add($AL->multiply($ce));
        wBH:
        $wz++;
        goto xFc;
        vHJ:
        ead:
        return $x4;
    }
    function _blind($Av, $AL, $wz)
    {
        $Av = $Av->multiply($AL->modPow($this->publicExponent, $this->primes[$wz]));
        $Av = $Av->modPow($this->exponents[$wz], $this->primes[$wz]);
        $AL = $AL->modInverse($this->primes[$wz]);
        $Av = $Av->multiply($AL);
        list(, $Av) = $Av->divide($this->primes[$wz]);
        return $Av;
    }
    function _equals($Av, $Pe)
    {
        if (!(strlen($Av) != strlen($Pe))) {
            goto m2k;
        }
        return false;
        m2k:
        $NU = 0;
        $wz = 0;
        xLY:
        if (!($wz < strlen($Av))) {
            goto eCp;
        }
        $NU |= ord($Av[$wz]) ^ ord($Pe[$wz]);
        ZLv:
        $wz++;
        goto xLY;
        eCp:
        return $NU == 0;
    }
    function _rsaep($x4)
    {
        if (!($x4->compare($this->zero) < 0 || $x4->compare($this->modulus) > 0)) {
            goto zJf;
        }
        user_error("\115\x65\x73\163\141\x67\x65\x20\162\x65\160\x72\145\x73\145\156\x74\x61\x74\151\166\x65\x20\157\165\164\x20\157\146\x20\x72\141\156\147\x65");
        return false;
        zJf:
        return $this->_exponentiate($x4);
    }
    function _rsadp($K6)
    {
        if (!($K6->compare($this->zero) < 0 || $K6->compare($this->modulus) > 0)) {
            goto t45;
        }
        user_error("\x43\x69\x70\150\x65\x72\x74\x65\170\x74\x20\x72\145\x70\162\145\163\x65\x6e\x74\x61\164\151\x76\145\40\x6f\x75\x74\40\x6f\146\40\162\141\156\x67\145");
        return false;
        t45:
        return $this->_exponentiate($K6);
    }
    function _rsasp1($x4)
    {
        if (!($x4->compare($this->zero) < 0 || $x4->compare($this->modulus) > 0)) {
            goto fJ3;
        }
        user_error("\115\x65\x73\x73\141\x67\145\x20\x72\x65\x70\x72\145\163\x65\x6e\164\x61\x74\x69\x76\x65\x20\x6f\x75\x74\x20\157\146\40\162\x61\x6e\x67\145");
        return false;
        fJ3:
        return $this->_exponentiate($x4);
    }
    function _rsavp1($bf)
    {
        if (!($bf->compare($this->zero) < 0 || $bf->compare($this->modulus) > 0)) {
            goto gQw;
        }
        user_error("\x53\151\147\x6e\x61\x74\165\162\145\40\162\145\160\162\x65\163\145\156\164\141\x74\x69\x76\x65\40\157\165\164\x20\157\146\40\162\141\x6e\147\145");
        return false;
        gQw:
        return $this->_exponentiate($bf);
    }
    function _mgf1($xz, $hQ)
    {
        $wq = '';
        $vz = ceil($hQ / $this->mgfHLen);
        $wz = 0;
        geC:
        if (!($wz < $vz)) {
            goto Fq2;
        }
        $K6 = pack("\x4e", $wz);
        $wq .= $this->mgfHash->hash($xz . $K6);
        p8j:
        $wz++;
        goto geC;
        Fq2:
        return substr($wq, 0, $hQ);
    }
    function _rsaes_oaep_encrypt($x4, $TH = '')
    {
        $Xa = strlen($x4);
        if (!($Xa > $this->k - 2 * $this->hLen - 2)) {
            goto R7U;
        }
        user_error("\115\x65\x73\x73\141\x67\145\40\x74\157\157\x20\x6c\157\x6e\147");
        return false;
        R7U:
        $X1 = $this->hash->hash($TH);
        $Xx = str_repeat(chr(0), $this->k - $Xa - 2 * $this->hLen - 2);
        $LA = $X1 . $Xx . chr(1) . $x4;
        $VZ = crypt_random_string($this->hLen);
        $f4 = $this->_mgf1($VZ, $this->k - $this->hLen - 1);
        $rK = $LA ^ $f4;
        $dV = $this->_mgf1($rK, $this->hLen);
        $iE = $VZ ^ $dV;
        $zM = chr(0) . $iE . $rK;
        $x4 = $this->_os2ip($zM);
        $K6 = $this->_rsaep($x4);
        $K6 = $this->_i2osp($K6, $this->k);
        return $K6;
    }
    function _rsaes_oaep_decrypt($K6, $TH = '')
    {
        if (!(strlen($K6) != $this->k || $this->k < 2 * $this->hLen + 2)) {
            goto o81;
        }
        user_error("\x44\145\143\162\x79\160\x74\151\x6f\156\40\145\x72\162\x6f\162");
        return false;
        o81:
        $K6 = $this->_os2ip($K6);
        $x4 = $this->_rsadp($K6);
        if (!($x4 === false)) {
            goto rUk;
        }
        user_error("\104\145\143\162\171\160\x74\x69\157\156\40\x65\x72\162\157\162");
        return false;
        rUk:
        $zM = $this->_i2osp($x4, $this->k);
        $X1 = $this->hash->hash($TH);
        $Pe = ord($zM[0]);
        $iE = substr($zM, 1, $this->hLen);
        $rK = substr($zM, $this->hLen + 1);
        $dV = $this->_mgf1($rK, $this->hLen);
        $VZ = $iE ^ $dV;
        $f4 = $this->_mgf1($VZ, $this->k - $this->hLen - 1);
        $LA = $rK ^ $f4;
        $iq = substr($LA, 0, $this->hLen);
        $x4 = substr($LA, $this->hLen);
        if ($this->_equals($X1, $iq)) {
            goto ewi;
        }
        user_error("\104\x65\x63\162\171\x70\164\x69\x6f\x6e\40\x65\162\162\157\x72");
        return false;
        ewi:
        $x4 = ltrim($x4, chr(0));
        if (!(ord($x4[0]) != 1)) {
            goto h9O;
        }
        user_error("\x44\145\143\x72\x79\160\x74\x69\x6f\156\40\145\162\162\157\162");
        return false;
        h9O:
        return substr($x4, 1);
    }
    function _raw_encrypt($x4)
    {
        $gu = $this->_os2ip($x4);
        $gu = $this->_rsaep($gu);
        return $this->_i2osp($gu, $this->k);
    }
    function _rsaes_pkcs1_v1_5_encrypt($x4)
    {
        $Xa = strlen($x4);
        if (!($Xa > $this->k - 11)) {
            goto fYG;
        }
        user_error("\115\145\163\163\141\x67\145\40\164\x6f\157\40\154\x6f\x6e\147");
        return false;
        fYG:
        $q7 = $this->k - $Xa - 3;
        $Xx = '';
        M2j:
        if (!(strlen($Xx) != $q7)) {
            goto hGq;
        }
        $gu = crypt_random_string($q7 - strlen($Xx));
        $gu = str_replace("\x0", '', $gu);
        $Xx .= $gu;
        goto M2j;
        hGq:
        $N4 = 2;
        if (!(defined("\103\x52\131\x50\x54\x5f\x52\x53\x41\x5f\120\113\x43\123\61\x35\x5f\x43\x4f\x4d\120\x41\x54") && (!isset($this->publicExponent) || $this->exponent !== $this->publicExponent))) {
            goto d4N;
        }
        $N4 = 1;
        $Xx = str_repeat("\377", $q7);
        d4N:
        $zM = chr(0) . chr($N4) . $Xx . chr(0) . $x4;
        $x4 = $this->_os2ip($zM);
        $K6 = $this->_rsaep($x4);
        $K6 = $this->_i2osp($K6, $this->k);
        return $K6;
    }
    function _rsaes_pkcs1_v1_5_decrypt($K6)
    {
        if (!(strlen($K6) != $this->k)) {
            goto kwk;
        }
        user_error("\x44\145\x63\x72\x79\160\164\x69\157\x6e\x20\145\x72\162\157\x72");
        return false;
        kwk:
        $K6 = $this->_os2ip($K6);
        $x4 = $this->_rsadp($K6);
        if (!($x4 === false)) {
            goto HM3;
        }
        user_error("\x44\x65\x63\x72\171\x70\164\151\157\x6e\x20\x65\162\x72\x6f\x72");
        return false;
        HM3:
        $zM = $this->_i2osp($x4, $this->k);
        if (!(ord($zM[0]) != 0 || ord($zM[1]) > 2)) {
            goto gry;
        }
        user_error("\x44\x65\x63\x72\171\x70\164\x69\x6f\156\40\x65\162\162\157\162");
        return false;
        gry:
        $Xx = substr($zM, 2, strpos($zM, chr(0), 2) - 2);
        $x4 = substr($zM, strlen($Xx) + 3);
        if (!(strlen($Xx) < 8)) {
            goto Uy0;
        }
        user_error("\104\x65\x63\x72\x79\x70\164\x69\x6f\x6e\x20\145\162\162\157\x72");
        return false;
        Uy0:
        return $x4;
    }
    function _emsa_pss_encode($x4, $jK)
    {
        $H5 = $jK + 1 >> 3;
        $QA = $this->sLen !== null ? $this->sLen : $this->hLen;
        $bl = $this->hash->hash($x4);
        if (!($H5 < $this->hLen + $QA + 2)) {
            goto g1c;
        }
        user_error("\x45\156\x63\157\x64\151\156\147\x20\x65\162\x72\x6f\x72");
        return false;
        g1c:
        $xW = crypt_random_string($QA);
        $lv = "\x0\x0\0\0\0\x0\x0\x0" . $bl . $xW;
        $ce = $this->hash->hash($lv);
        $Xx = str_repeat(chr(0), $H5 - $QA - $this->hLen - 2);
        $LA = $Xx . chr(1) . $xW;
        $f4 = $this->_mgf1($ce, $H5 - $this->hLen - 1);
        $rK = $LA ^ $f4;
        $rK[0] = ~chr(0xff << ($jK & 7)) & $rK[0];
        $zM = $rK . $ce . chr(0xbc);
        return $zM;
    }
    function _emsa_pss_verify($x4, $zM, $jK)
    {
        $H5 = $jK + 1 >> 3;
        $QA = $this->sLen !== null ? $this->sLen : $this->hLen;
        $bl = $this->hash->hash($x4);
        if (!($H5 < $this->hLen + $QA + 2)) {
            goto AF4;
        }
        return false;
        AF4:
        if (!($zM[strlen($zM) - 1] != chr(0xbc))) {
            goto HBA;
        }
        return false;
        HBA:
        $rK = substr($zM, 0, -$this->hLen - 1);
        $ce = substr($zM, -$this->hLen - 1, $this->hLen);
        $gu = chr(0xff << ($jK & 7));
        if (!((~$rK[0] & $gu) != $gu)) {
            goto A4b;
        }
        return false;
        A4b:
        $f4 = $this->_mgf1($ce, $H5 - $this->hLen - 1);
        $LA = $rK ^ $f4;
        $LA[0] = ~chr(0xff << ($jK & 7)) & $LA[0];
        $gu = $H5 - $this->hLen - $QA - 2;
        if (!(substr($LA, 0, $gu) != str_repeat(chr(0), $gu) || ord($LA[$gu]) != 1)) {
            goto GN8;
        }
        return false;
        GN8:
        $xW = substr($LA, $gu + 1);
        $lv = "\0\x0\x0\0\x0\0\0\x0" . $bl . $xW;
        $oC = $this->hash->hash($lv);
        return $this->_equals($ce, $oC);
    }
    function _rsassa_pss_sign($x4)
    {
        $zM = $this->_emsa_pss_encode($x4, 8 * $this->k - 1);
        $x4 = $this->_os2ip($zM);
        $bf = $this->_rsasp1($x4);
        $bf = $this->_i2osp($bf, $this->k);
        return $bf;
    }
    function _rsassa_pss_verify($x4, $bf)
    {
        if (!(strlen($bf) != $this->k)) {
            goto Aym;
        }
        user_error("\111\x6e\x76\141\154\x69\x64\x20\163\x69\147\156\141\x74\x75\x72\x65");
        return false;
        Aym:
        $f9 = 8 * $this->k;
        $jJ = $this->_os2ip($bf);
        $lv = $this->_rsavp1($jJ);
        if (!($lv === false)) {
            goto bUN;
        }
        user_error("\111\x6e\166\x61\x6c\x69\x64\40\163\151\x67\x6e\141\164\x75\162\x65");
        return false;
        bUN:
        $zM = $this->_i2osp($lv, $f9 >> 3);
        if (!($zM === false)) {
            goto k_y;
        }
        user_error("\x49\156\x76\141\x6c\x69\x64\x20\163\x69\147\x6e\x61\x74\x75\x72\145");
        return false;
        k_y:
        return $this->_emsa_pss_verify($x4, $zM, $f9 - 1);
    }
    function _emsa_pkcs1_v1_5_encode($x4, $H5)
    {
        $ce = $this->hash->hash($x4);
        if (!($ce === false)) {
            goto mVz;
        }
        return false;
        mVz:
        switch ($this->hashName) {
            case "\155\144\62":
                $wq = pack("\x48\52", "\x33\x30\x32\x30\63\x30\60\143\60\x36\x30\70\x32\141\70\x36\64\70\70\66\x66\x37\60\144\x30\62\60\62\60\x35\60\60\x30\x34\x31\x30");
                goto JLi;
            case "\155\144\65":
                $wq = pack("\x48\x2a", "\63\60\x32\60\x33\60\60\x63\60\x36\x30\x38\x32\141\x38\x36\64\x38\70\x36\146\67\60\x64\60\x32\60\x35\60\65\60\x30\60\x34\x31\60");
                goto JLi;
            case "\x73\150\141\x31":
                $wq = pack("\110\52", "\x33\x30\x32\61\63\x30\x30\71\60\66\60\x35\62\142\x30\145\60\x33\60\x32\x31\x61\x30\x35\x30\60\x30\64\x31\64");
                goto JLi;
            case "\x73\x68\141\62\65\66":
                $wq = pack("\x48\x2a", "\63\x30\x33\61\63\60\60\144\x30\x36\x30\71\66\x30\x38\66\64\x38\60\61\x36\x35\60\x33\60\64\60\x32\x30\x31\60\65\60\x30\x30\x34\x32\60");
                goto JLi;
            case "\163\150\141\x33\70\64":
                $wq = pack("\x48\x2a", "\63\x30\x34\x31\63\x30\x30\144\x30\x36\x30\71\x36\x30\x38\x36\64\70\x30\61\x36\65\60\x33\60\64\60\62\60\62\x30\65\x30\x30\60\64\x33\60");
                goto JLi;
            case "\163\x68\x61\65\61\x32":
                $wq = pack("\110\x2a", "\x33\x30\x35\61\63\x30\x30\144\60\x36\60\x39\x36\x30\x38\x36\64\70\60\61\66\65\60\x33\x30\x34\60\x32\x30\63\x30\x35\x30\60\x30\x34\x34\x30");
        }
        xZe:
        JLi:
        $wq .= $ce;
        $Il = strlen($wq);
        if (!($H5 < $Il + 11)) {
            goto d6u;
        }
        user_error("\x49\x6e\164\x65\156\144\x65\x64\x20\145\156\143\157\144\145\144\x20\155\x65\163\163\x61\x67\x65\40\154\x65\x6e\x67\x74\x68\x20\x74\157\x6f\40\163\x68\157\x72\x74");
        return false;
        d6u:
        $Xx = str_repeat(chr(0xff), $H5 - $Il - 3);
        $zM = "\0\1{$Xx}\x0{$wq}";
        return $zM;
    }
    function _rsassa_pkcs1_v1_5_sign($x4)
    {
        $zM = $this->_emsa_pkcs1_v1_5_encode($x4, $this->k);
        if (!($zM === false)) {
            goto GUG;
        }
        user_error("\122\x53\101\40\x6d\157\x64\x75\x6c\165\163\40\164\x6f\157\x20\x73\150\x6f\162\x74");
        return false;
        GUG:
        $x4 = $this->_os2ip($zM);
        $bf = $this->_rsasp1($x4);
        $bf = $this->_i2osp($bf, $this->k);
        return $bf;
    }
    function _rsassa_pkcs1_v1_5_verify($x4, $bf)
    {
        if (!(strlen($bf) != $this->k)) {
            goto Mv4;
        }
        user_error("\111\156\x76\141\154\x69\x64\x20\x73\151\147\156\x61\164\165\x72\x65");
        return false;
        Mv4:
        $bf = $this->_os2ip($bf);
        $lv = $this->_rsavp1($bf);
        if (!($lv === false)) {
            goto Sjd;
        }
        user_error("\x49\x6e\166\x61\154\x69\x64\40\x73\x69\147\x6e\141\x74\165\162\x65");
        return false;
        Sjd:
        $zM = $this->_i2osp($lv, $this->k);
        if (!($zM === false)) {
            goto Fov;
        }
        user_error("\x49\x6e\166\141\154\x69\x64\x20\163\151\x67\156\141\164\165\162\145");
        return false;
        Fov:
        $Cb = $this->_emsa_pkcs1_v1_5_encode($x4, $this->k);
        if (!($Cb === false)) {
            goto KL2;
        }
        user_error("\x52\123\101\40\x6d\x6f\144\165\x6c\x75\163\40\164\x6f\x6f\40\163\150\x6f\162\x74");
        return false;
        KL2:
        return $this->_equals($zM, $Cb);
    }
    function setEncryptionMode($qi)
    {
        $this->encryptionMode = $qi;
    }
    function setSignatureMode($qi)
    {
        $this->signatureMode = $qi;
    }
    function setComment($hl)
    {
        $this->comment = $hl;
    }
    function getComment()
    {
        return $this->comment;
    }
    function encrypt($Io)
    {
        switch ($this->encryptionMode) {
            case CRYPT_RSA_ENCRYPTION_NONE:
                $Io = str_split($Io, $this->k);
                $Rl = '';
                foreach ($Io as $x4) {
                    $Rl .= $this->_raw_encrypt($x4);
                    Z_r:
                }
                jmp:
                return $Rl;
            case CRYPT_RSA_ENCRYPTION_PKCS1:
                $ql = $this->k - 11;
                if (!($ql <= 0)) {
                    goto kp5;
                }
                return false;
                kp5:
                $Io = str_split($Io, $ql);
                $Rl = '';
                foreach ($Io as $x4) {
                    $Rl .= $this->_rsaes_pkcs1_v1_5_encrypt($x4);
                    eQR:
                }
                hiv:
                return $Rl;
            default:
                $ql = $this->k - 2 * $this->hLen - 2;
                if (!($ql <= 0)) {
                    goto ZqU;
                }
                return false;
                ZqU:
                $Io = str_split($Io, $ql);
                $Rl = '';
                foreach ($Io as $x4) {
                    $Rl .= $this->_rsaes_oaep_encrypt($x4);
                    Oqd:
                }
                JKB:
                return $Rl;
        }
        DBE:
        O5L:
    }
    function decrypt($Rl)
    {
        if (!($this->k <= 0)) {
            goto c73;
        }
        return false;
        c73:
        $Rl = str_split($Rl, $this->k);
        $Rl[count($Rl) - 1] = str_pad($Rl[count($Rl) - 1], $this->k, chr(0), STR_PAD_LEFT);
        $Io = '';
        switch ($this->encryptionMode) {
            case CRYPT_RSA_ENCRYPTION_NONE:
                $Jj = "\137\x72\x61\167\137\145\156\143\162\171\160\164";
                goto tYb;
            case CRYPT_RSA_ENCRYPTION_PKCS1:
                $Jj = "\137\162\163\x61\x65\x73\x5f\160\x6b\x63\163\x31\x5f\x76\x31\x5f\x35\x5f\x64\145\143\162\171\x70\164";
                goto tYb;
            default:
                $Jj = "\x5f\x72\x73\141\145\163\x5f\x6f\141\145\160\x5f\144\145\143\x72\171\x70\x74";
        }
        Zk4:
        tYb:
        foreach ($Rl as $K6) {
            $gu = $this->{$Jj}($K6);
            if (!($gu === false)) {
                goto rqO;
            }
            return false;
            rqO:
            $Io .= $gu;
            UmU:
        }
        COd:
        return $Io;
    }
    function sign($Kv)
    {
        if (!(empty($this->modulus) || empty($this->exponent))) {
            goto azK;
        }
        return false;
        azK:
        switch ($this->signatureMode) {
            case CRYPT_RSA_SIGNATURE_PKCS1:
                return $this->_rsassa_pkcs1_v1_5_sign($Kv);
            default:
                return $this->_rsassa_pss_sign($Kv);
        }
        O4P:
        Wkq:
    }
    function verify($Kv, $Zs)
    {
        if (!(empty($this->modulus) || empty($this->exponent))) {
            goto ad1;
        }
        return false;
        ad1:
        switch ($this->signatureMode) {
            case CRYPT_RSA_SIGNATURE_PKCS1:
                return $this->_rsassa_pkcs1_v1_5_verify($Kv, $Zs);
            default:
                return $this->_rsassa_pss_verify($Kv, $Zs);
        }
        lqU:
        MHW:
    }
    function _extractBER($MQ)
    {
        $gu = preg_replace("\x23\56\x2a\x3f\x5e\x2d\53\x5b\136\x2d\135\x2b\55\53\133\134\162\x5c\x6e\x20\135\52\x24\43\x6d\163", '', $MQ, 1);
        $gu = preg_replace("\x23\x2d\53\x5b\136\55\x5d\x2b\55\53\43", '', $gu);
        $gu = str_replace(array("\xd", "\12", "\x20"), '', $gu);
        $gu = preg_match("\43\x5e\133\141\55\172\x41\55\x5a\x5c\x64\57\x2b\x5d\x2a\x3d\173\60\x2c\x32\175\x24\43", $gu) ? base64_decode($gu) : false;
        return $gu != false ? $gu : $MQ;
    }
}
